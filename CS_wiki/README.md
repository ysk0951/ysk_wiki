#  Computer Sciense Dictionary

### 001 소프트웨어 생명주기
> 소프트웨어 생명주기
* SoftWare Life Cycle
* 소프트웨어를 개발하기 위한 / 과정을 각 단계별로 나눈것
* 설계, 운용, 유지보수

> 폭포수 모형
* Waterfall Model
* 각 단계를 매듭짓고 / 검토하여 승인과정을 거친후 / 다음단계를 진행

> 프로토타입 모형
* Prototype model
* 실제 개발될 소프트웨어의 견본품을 만들어 / 최종결과물을 예측

> 애자일 모형
* Agile Model
* 요구사항의 변화에 유연하게 대응 / 일정한 주기를 반복하면서 개발

> 소프트웨어 공학
* 소프트웨어 위기 극복이 목적
* 현대적 프로그래밍 기술을 적용
* 개발된 소프트웨어의 품질 유지를 위한 지속적 검증
* 명확한 기록 유지

### 002 스크럼
> 스크럼
* Scrum
* 팀이 중심이 되어 개발의 효율성이 높이는 기법

> Scrum Team
* > PO
  * Product Manager
  * 백로그 작성 주체
* > SM
  * Scream Master
  * 스크럼 가이드
* > DT
  * Development Team
  * PO , SM을 제외한 모든 팀원 개발진

> Scrum 개발 프로세스
* > 스프린트 계획 회의
  * Sprint Planning Meeting
  * 제품 백로그중 이번 스프린트에서 수행할 작업 일정수립
* > 스프린트
  * Sprint 
  * 2~4주 개발진행
* > 일일 스크럽 회의
  * Daily Scrum Meeting
  * 15분정도 진행상황 점검
  * 남은 작업 소멸차트 표시 (Burn Down Chart)
* > 스프린트 검토회의
  * Spring Review
  * 요구사항에 잘 부합하는지 테스팅 회의
* > 스프린트 회고
  * Spring Retospective
  * 개선점 기록

### 003 XP
> eXtream Programming
* 요구사항에 유연하게 대응 / 고객의 참여와 개발을 반복 / 생산성을 향상
* > 핵심가치 5가지
  * 의사소통
  * 단순성
  * 용기
  * 존중
  * 피드백
* > XP 주요 설정방법  
  * > Pair Programming
    * 다른사람과 함께 프로그래밍 수행, 개발책임 공동으로 가짐
  * > Collective Ownership
    * 코드 권한과 책임을 공동으로 소유
  * > Test Driven Development
  * > whole Team
  * > Continuous Intergration
  * > Refactoring
  * > Small Releases

### 004 개발 기술 환경
> OS
* Operating System
* 컴퓨터 시스템의 자원을 효율적으로 관리
* > 운영체재 요구사항 식별시 고려사항
  * 가용성
  * 성능
  * 기술지원
  * 구축비용
  * 주변기기

> DBMS
* DataBase Management System
* 사용자와 데이터베이스 사이에서 정보를 생성, 관리해주는 소프트웨어
* > DBMS 요구사항 식별시 고려사항
  * 가용성
  * 성능
  * 기술지원
  * 구축비용
  * 상호호환성

> WAS
* Web Application Server
* 동적인 컨텐츠를 처리하기 위한 미들웨어
* > WAS 요구사항 식별시 고려사항
  * 가용성
  * 성능
  * 기술지원
  * 구축비용

> 오픈소스
* 누구나 제한없이 사용할수 있도록 소스코드를 공개한 소프트웨어
* > OpenSource 요구사항 식별시 고려사항
  * 라이센스 종류
  * 사용자수
  * 기술 지속 가능성

### 005 요구사항 정의
> 요구사항 정의 
* 소프트웨어가 어떤 문제를 해결하기 위해 제공되는 서비스에 대한 설명
* 운영되는데 필요한 제약조건
> 기능 요구사항
* 기능이나 수행과 관련된 요구사항들
> 비기능 요구사항 
* 품질이나 제약사항과 관련된 요구사항
> 사용자 요구사항
* 사용자 관점에서 본 시스템이 제공해야할 요구사항
> 시스템 요구사항
* 개발자 관점에서 본 시스템 전체가 제공해야할 요구사항

### 006 요구사항 개발 프로세스
> 요구사항 도출
* Requirement Elicitation
* > 요구사항 도출 기법
  * 청취 , 인터뷰
  * 설문
  * 브레인스토밍
  * 워크샵
  * 프로토타이핑
  * 유스케이스
> 요구사항 분석
* Requirement Analysis
* 요구사항중 이해되지 않는 부분을 걸러내기위한 과정
* DFD, DD
> 요구사항 명세 
* 문서화 하는 과정
> 요구사항 확인
* 문서를 검증하는 과정
> 요구사항 공학
* 요구사항 명세 프로세스 연구하는 학문
> 요구사항 명세 기법
* 정형 명세 기법 (수학)
* 비정형 명세 기법 (자연어)

### 007 요구사항 분석
> 요구사항 분석 
* 개발 대상에 대한 요구사항을 이해하고 명세하는 작업
> 구조적 기법
* 자료의 흐름과 처리를 중심으로 하는 분석방법
> 구조적 기법 도구
* DFD
* DD
* Mini-Spec (소단위 명세서)
* ERD
* STD (상태 전이도)
* 제어명세서
> DFD
* 자료의 흐름및 변환과정과 기능을 도형으로 기술
* Process , Data Flow, Data Store , Terminator
> DD
* =
* (기호)+
* ()
* []
* {}
* (기호)**
* 정의 연결 생략 선택 반복 설명(주석)

### 008 요구사항 분석 CASE , HIPO
> CASE
* 자동으로 분석하고, 명세서를 기술하는 도구
* 개발사와 특징구분
* SADT
* SREM = RSL/REVS
* PSL/PSA
* TAGS
> HIPO
* Hierarchy Input Process Output
* 시스템 실행과정인 입력 , 처리 , 출력의 기능 표현
* 하향식
* 가시적 , 총체적, 세부적 도표

### 009 UML
> Unified Modeling Language
* 개발과정에서 의사소통을 도와주는 표준화된 객체지향 모델링 언어
> 구성요소
* 사물
* 관계
* 다이어그램
> 사물
* 관계가 형성될수있는 대상
> 종류
* 구조 사물
* 행동 사물
* 그룹 사물
* 주해 사물(Annotation)

### 010 UML 관계
> 관계
* 사물사이의 연관성
> 종류
* > 연관
  * 다중도위의 선으로 표헌 , 양방향일시 화살표생략, 실선표현
* > 집합
  * 하나의 사물이 다른사물에 포함
  * 마름모로 표현
* > 포함
  * 사물의 변화가 포함되는 사물에 영향을 미침(집합은 전제)
* > 일반화
  * 더 일반적이거나 더 구체적인 관계(빈 화살표)
* > 의존
  * 짧은시간동안만 연관유지(점선 화살표)
* > 실체화
  * 해야하는 기능을 그룹화

# 😃 설계와 테스트
</hr>

설계의 방향
-----  
> 상향식설계, 하향식설계 의 기준을 설명하시오 
* 설계의 세부사항, 인터페이스의 완성도가 아님  
* **결합의 여부**가 상향식이냐 하향식이냐
> 워크스루와 인스펙션의 차이
* 작성자 제외여부 (인스펙션)

설계분석론
----
> Wrfs-Block
* 분석과 설계의 구분없이 고객명세서부터 설계작업까지 연속적 수행을 하는 설계론
> Rumhaugh
* 객체, 동적, 기능순으로 분석하는 분석론
> Booch
* Micro와 Macro로 나눠서 분석하는 방식
> Jacobson
* UseCase로 분석하는 방식
> Coad-Yorudon
* E-R 다이어그램을 사용하여 객체 행위 모델링을 통해 분석하는 방식
> LOC (Line *)
* 낙관 / 기대 / 비관   
> 테일러링   

> PUTNAM   
* 소프트웨어 개발 주기의 간 단계별로 요구할 인력의 분포를 가정하는 모형
* Putnam 모형과 Rayleigh Noden 곡선을 기초로 개발한 자동화 추정 도구로 SLIM, ESTIMACS가 있다
> FP (Function *)   
* 기능점수(FP) 모형 (비용산정)
> PERT (Program * Technique)   
* 프로그램 평가(Program Evaluation) 및 검토 기법(Review Technique)
> 델파이기법  
* 전문가들의 의견수립, 중재, 타협의 방식으로 반복적인 피드백을 통한 하향식 의견 도출 방법으로 문제를 해결하는 기법
> Effort Per Task   
* 개발 단계별 인월수 기법은 LOC 기법을 보완하기 위한 기법
* 각 기능을 구현시키는 데 필요한 노력을 생명 주기의 각 단계별로 산정
> 유스케이스 다이어그램
  * > 확장
    * 확장대상 유스케이스를 수행할때 특정 조건에 따라 수행
  * > 포함
    * 하나의 유스케이스가 다른 유스케이스의 실행을 전재로함
  * > 일반화
    * 유사한 유스케이스 또는 액터를 모아 추상화한것
> 설계론 (상위/하위)
* 외부 / 내부 구분 - 모듈은 내부에 속함
> 소프트웨어 개발비용이 가장많이 드는 구간
* 유지보수

NUI List
----
> Pan   
* Touch, Hold, Move
> Flick   
* Quickly Brush
> Pinch   
* Touch surface with Two Fingers and bring then closer or apart
소스코드 품질분석 도구
----
> PMD (* mistacke *)
* PMD(Programming Mistake Detector)
* 응용 프로그램 코드에서 발견 된 문제를 보고 하는 오픈 소스 정적 Java 소스 코드 분석기
> cppcheck
*  Cppcheck는 크로스 플랫폼(윈도우, 데비안, 페도라, 맥 등)을 지원하며, 개발IDE에 플러그인으로 연동할 수 있습니다
> sonarQube
* 정적 코드 분석으로 코드 품질 검사용 오픈 소스 플랫폼
> ccm (* complicated *)
* 다양한 언어의 복잡도 분석
> cobertuna
* 자바 언어의 소스코드 복잡도 분석 및 테스트 커버리지 측정

UI 설계도구
-----  
> 와이어프레임~프로토타입의 순서를 설명하시오  
* 와이어프레임 > 목업 > 스토리보드 > 프로토타입    

자료흐름도
----
> 프로세스
* 버블이라고도함 (원)
> 자표흐름
* 화살표
> Data Store
* 평행선
> 단말 (외부개체)
* 사각형

자료사전 표기기호
----
> 정의
* =
> 연결
* 덧셈 기호 +   
> 생략
* ()
> 선택
* []
> 반복
* {}
> 설명
* 기호 **

Agile Scrum에서 각각의 단어를 설명하시오
-----  
> Backlog   
> Sprint(2~4w)   
> Velocity   

요구분석
----
> 기능적 요구
* 주로 코드상의 내용
> 비기능적 요구
* 주로 품질에 대한 내용

아키텍처
----
> 마스터 슬레이브 아키텍쳐
* > 슬레이브의 제한사항
  * 슬레이브는 마스터의 기능(연산,통신,조정) 외에 제한없음
> 레이어패턴
* 각 레이어는 해당 레이어가 의존하는 직접적인 하위 레이어만 알면 됨
> 파이프 패턴
* 각 pipe 함수는 다음 pipe 함수로 전달하면서 작업을 처리한다. 즉, 연속적인 데이터의 흐름을 처리하는 일련의 함수들을 나열한 것
> SOA (* oriendted *)
* 서비스 인터페이스를 활용하여 소프트웨어 구성 요소를 재사용할 수 있게 만드는 설계 유형
* 표현, 비즈니스, 프로세스, 중간, 에플리케이션, 데이터저장

UML 
----
> 정적 다이어그램
  * > 클래스
    * > 구성요소
      * 이름, 속성, 오퍼레이션
  * > 객체
  * > 컴포넌트
  * > 배치
  * > 복합체
  * > 패키지
> 동적 다이어그램
  * > 유스케이스
  * > 순차
    * 시간 개념 중심의 다이어그램
  * > 커뮤니케이션
  * > 상태
  * > 활동
> 포함과 집합
  * 포함은 집합의 특수한 형태
> 사물이 해야하는 기능(오퍼레이션)을 지정하는 UML
  * 실체화 UML
> 구성요소
  * 사물 , 관계 , 다이어그램
> 스테레오타입 기호 
  * <<>>
개발모형
----
> 나선형
* 리스크관리
> 폭포수 변환
* V모델
> HIPO 
* Hierarchy Input Process Output
* 하향식 소프트웨어 개발을 위한 문서화 도구
> 라우터   
* 컴퓨팅 디바이스와 네트워크를 다른 네트워크에 연결하는 네트워킹 디바이스
> RAD (Rapid *)
* Rapid Application Development 
* 도구로 디자인하고 Code Generator를 활용해 빠르게 개발하는 기법

테스트
----
> 스텁이란?
* 서버가 구현, 하위모듈을 대체
* 하향식 통합테스트, 정해진 객체 결과값을 서버에 전달
> 태스트 드라이버란?
* 클라이언트가 후현, 상향모듈을 대체
* 인자값을 넘겨주는 상향식 통합테스트
> CASE(Computer Aided SoftWare Enginerring)
* 자동화 도구, 테스트 방법론
  > 상위 케이스
    * 문제를 기술, 설계 지원
  > 하위 케이스
    * 코드 작성테스트, 문서화 지원
  > 통합 케이스
    * 생명주기에 포함되어있는 전과정 지원
> 테스트 오라클 
* 미리정의된 참을 대입하여 실제 결과와 비교
  * > 참 오라클
    * 모든 케이스에 대해서 전수테스트
  * > 샘플링 오라클
    * 특정 입력값들에 대해서만 원하는 결과제공
  * > 휴리스틱 오라클
    *  샘플링 오라클 개선, 참이 아닌 결과값은 휴리스틱(직관)처리
  * > 일관성 검사 오라클
    * 이전 수행결과와 현재 수행결과가 동일한지 검증


테스트 이론
----
> FTR (Formal Technical Review)
* 검토에만 집중하기 위해, 검토 이외의것을 모두 제한하는 방식(논쟁,인원 등등)
> Revese Engineering
* 일반적인 개발 단계와는 반대로 기존 코드를 복구하거나 소프트웨어 관계를 추출하는 방식
> Alien Code
* 참고문서와 관리하는 개발자가 없어 유지보수가 어려운 프로그램 코드
> 화이트박스 검사, 블랙박스 검사
* 실행 경로의 기초(내부적)를 정의하는 검사와, 내부를 보지않고 입력과 출력에 중점을 둔 검사의 차이
> 알파테스트 , 베타테스트
* 내부테스트(개발진, QA) , 상용테스트(일반인)   
<br/>

인터페이스 구현 검증 도구
---
> xUnit
  * 단위테스트가 핵심   
> TAF (* Automation *)  
  * > Test Automation Framwork
    * STAF, NTAF
    * 컴포넌트및 서비스 테스트 자동화가 핵심
> FitNesse
  * Test Wiki
> watir
  * Ruby Test

기타개념
----
> Cocomo Model Line Standard
* 5만, 30만 
* 조직, 반분리, 내장 
> Basis Path
  * 수행가능한 모든 경로 
> DFD
* 요구사항에서 데이터의 흐름
> DD 
* 자료흐름들을 더 자세히 사전처럼 기록
> Mini-Spec
* 세분화된 자료흐름에서 최하위 단계 처리절차 기술하는것
> ERD
* 개체 관계도
> STD
* 특정 일이 발생할 경우 시스템간의 상태 전이모델
> SADT (* Analysis and Design *)
* Structured Analysis and Design Techniques 
* 그래픽언어를 사용하여 시스템 모델을 구축 S/W 
* 요구사항 분석과 설계를 위한 구조적 분석과 설계기법 또는 도구
> Wavelength Division Multiplexing
* 파장이 서로 다른 광신호 광섬유 다중화 기술

</br></br>

# 😃 개발 디자인
</hr>

SOLID
----
> S
* Solo Responsibility
> O
* Open-close
> L
* Liskov : super()
> I
* Interface Segregation
> D
* Dependency : child -> parent

GoF 디자인패턴의 종류
----
> 3가지 분류 기준
* 생성 / 구조 / 행위
  > 생성의 네가지 종류  
    * 팩토리 , 빌더 , 프로토 , 싱글톤
    * > 팩토리   
      * > 추상팩토리  
        * 인터페이스
      * > 팩토리 메소드 
        * 객체 생성을 서브클래스에서
    * > 빌더
      * 인스턴스의 조합
    * > 프로토
      * 원본객체를 복사
    * > 싱글톤   
  > 구조
    * > 구조값이라고 상상 가능한 패턴
      * > 어뎁터
        * 호환성 없는 클래스들을 이용할수 있도록 변환
      * > 브릿지
        * 구현부에서 추상층 분리, 독립적 확장
      * > 데코레이터
        * 객체간의 결합을 통해 기능확장
      * > 프록시
        * 접근하기 어려운 객체에 연결
    * > 구조값이라고 상상 불가능했던 패턴
      * > 컴포지트
        * 복합객체, 단일객체 구분없이 사용
      * > 퍼싸드
        * 복잡한 서프클래스를 피해 더 상위 인터페이스
      * > 플라이웨이트
        * 인스턴스를 가능한한 공유해서 씀
  > 행위
    * > 행위값이라고 상상 가능했던 패턴
      * > 책임연쇄
        * 객체가 둘 이상 존재하면, 한객체가 처리하지 못할시에 다음으로 넘어가는 패턴
      * > 옵저버
        * 변화하는 상태를 전달
    * > 행위값이라고 상상 불가능했던 패턴
      * > 상태
        * 객체의 상태값에 따라서 동일한 동작을 다르게 처리
      * > 방문자
        * 데이터 구조에서 처리기능을 분리, 별도의 클래스로 구성하는 패턴
      * > 커맨드
        * 요청을 객체의 형태로 캡슐화 하고, 로그에 남기는 패턴
      * > 인터프리터
        * 언어에 문법 표현을 정의
      * > 반복자
        * 동일한 인터페이스를 사용
      * > 중재자
        * 수많은 객체간의 복잡한 상호작용을 캡슐화
      * > 메멘토
        * 특정 시점의 객체 내부상태를 객체화
      * > 전략
        * 동일계열 알고리즘을 개별적으로 캡슐화
      * > 템플릿메소드
        * 상위 클래스에서 골격을 정의, 하위클래스에서 세부처리

> 디자인패턴에 대한 새로운 표현
* 자주 발생하는 문제에 대한 반복적인 해결방법

> CMM 모델 (조직의 성숙도)
* 초기 
* 관리 
* 정의 
* 정량 
* 최적화

응집도과 결합도
----
> 좋은소프트웨어
* 응집도는 높게(명령에 대한 구조) , 결합도는 낮게
> 응집도 순서 (아웃풋이 얼마나 스노우볼이 구르는지)
* 기능적
* 순차적 (순차가 끝나면 그다음은)
* 통신적 (통신한 모듈끼리 모이면)
* 절차 (절차들이 모이면)
* 시간 (시간이 모여야)
* 논리 (논리가 된다)
* 우연 : 어떤 의미도 없이 연관관계가 없는것
> 결합도 순서 
* (전체에서 점점 작아지고나서, 작아진것에서도 신호 -> 인터페이스 -> 파라미터순으로 작아짐)
* 내용
* 공통
* 외부
* 제어
* 스탬프 (스탬프가 인터페이스를 의미)
* 자료

</br></br>

# 😃 네트워크
</hr>

경로제어 routing 프로토콜
---
> IGP (Interior *)
  * > Interior Gateway Protocol (동일그룹)
  * > OSPF (* Shortest *)
    * Open Shortest Path First
  * > RIP (* imfomation *)
    * > Routing Infomation Protocol
      * Hop Counting
> EGP   
  * > Exterior Gateway Protocol (외부그룹)
> BGP   
  * > Boarder Gateway protocol (종속 게이트웨이)

> 임계 구역 접근 상호 배제
* Semaphore (신호깃발이라는 뜻)
> FAT -> NTFS
* 상대적 대용량, 대신 속도가 늘려짐 
> VLAN   
* 논리적으로 분할된 스위치 네트워크 : 동적인 조직에서 작업 그룹을 구성할 수 있음
> STP (* Tree *)
* Spannging Tree Protocol
* 2개 이상의 스위치가 여러 경로로 연결될때, 무한 루프 현상을 막기 위해 우선순위에 따라 1개로 통신하는 프로토콜
> L2AN
* OSI의 2계층에 속하는 장비
* MAC 주소를 기반으로 프레임을 전송하고 동일 네트워크 간의 연결만 가능
> SDS (Software *)
* Software Defined Storage 
* 스토리지를 가상화하여 여러 스토리지를 하나처럼 관리하거나, 여러 스토리지로 나눠 사용하는 소프트웨어
> SDDC (* data Center)
* Software-defined Data Center 
* 데이터센터의 모든 인프라인 네트워크, 스토리지, 컴퓨터, 보안 등이 가상화 되어 제공되는 데이터센터 솔루션
> MLFQ (Multi level *) 
* Multi-level Feedback Queue - MLFQ는 여러 개의 큐로 구성되며, 각각 다른 우선순위(Priority level)가 배정된다. 
* 실행 준비가 된 프로세스는 이 중 하나의 큐에 존재한다. MLFQ는 실행할 프로세스를 결정하기 위하여 우선순위를 사용한다. 
* 높은 우선순위를 가진 작업, 즉 높은 우선순위 큐에 존재하는 작업이 선택된다. 
> MQTT (Message * Transport)
* Message Queuing Telemetry Transport 
* 경량 머신 대 머신 통신에 사용되는 표준 기반 메시징 프로토콜
* 발행 - 구독 기반의 메세징 프로토콜
> Zingbee   
* 소형, 저전력 디지털 라디오를 이용해 개인 통신망을 구성하여 통신하기 위한 표준 기술
> MessageBus   

> Hub & Spoke   

> HyBrid   
 
> MBR(master *)   
* master boot record - 파티션된 기억 장치(이를테면 하드 디스크)의 첫 섹터 (섹터 0)인 512 바이트 시동 섹터이다   
> NAC (* Access *)
* 네트워크 접근제어(Network Access Control)
* 인가된 장치만이 네트워크에 접속할 수 있도록 제한하는 것
> NIC(* interface *)
* 네트워크 인터페이스 컨트롤러(network interface controller, NIC)
* 네트워크에 연결하여 통신하기 위해 사용하는 하드웨어 장치
> Topology   
* 단어 그 자체로 망 구성방식
* 컴퓨터 네트워크의 요소들(링크, 노드 등)을 물리적으로 연결해 놓은 것, 또는 그 연결 방식
> SNMP (Simple Network *)
*  UDP/IP(사용자 데이터그램 프로토콜/인터넷 프로토콜)를 사용하여 이더넷 연결을 통해 네트워크 관리 작업을 수행하는 응용 계층 프로토콜 
> FLSM (Fixed Length *)
* Fixed Length Subnet Mask  <-> VariableLength Subnet Mask
> ARQ (* Request)
* ARQ는 Automatic Repeat Request
* 에러가 발생할 경우 재전송을 요구하는 방식이다. 
> 유니캐스트 , 브로드캐스트 , 멀티캐스트, 애니캐스트
* 유니캐스트는 한 PC에게만 보내는 1:1
* 브로드 케스트는, 도메인 안에있는 모든 PC들에게 보내는 형태
* 멀티캐스트는, 원하는 그룹에게만 보내는방식
* 애니캐스트는 가장가까운 Node에게 보내는 방식
> Wi-Sun
* Wireless Smart Utility Network
* 일본에서는 특정 소전력 무선으로 일컬어지는 920MHz 대에서 사용
> Sliding Window
* 일단 '윈도(메모리 버퍼의 일정 영역)'에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인되는대로 이 윈도를 옆으로 옮김(slide)으로서 그 다음 패킷들을 전송하는 방식
> GPIB(* Purpose Interface *)
* General Purpose Interface Bus
* PC를 통하여 계측기나 기타 장비 등 표준 프로토콜로 병렬 및 고속 제어하기 위하여 사용

IPv4와 IPv6정리
----
> 유니캐스트(1:1 통신 주소 자동설정)
* IPv4 
> 클래스별로 4개
* IPv4 
> 16비트 8개 -> 128비트
* IPv6
> 40옥텟 해더
* IPv6
> 속도가 비교적 빠르고 v4와 호완
* IPv6
> 패킷 크기가 고정 / 비고정
* IPv4 / IPv6

TCP/IP + UDP
----
> ARP(Address * *)
* IP to MAC Address (Address Resolution Protocol) 프로토콜
> ICMP (* Message Protocol)
* Error Message - Internet Control Message Protocol
> Point to Point
* 각각 서버와 클라이언트가 둘다 될수있는 방식(Point to Point)의 프로토콜
> TCP/UDP
* 차이는 연결형 / 비연결형 으로 속도와 신뢰성의 문제
> OSI 2계층은 인접하는 신뢰, 종단간은 신뢰는
* 4계층

IPv4 Class 정리
----
> A (0)   
* 0.0.0.0 ~ 127.255.255.255
> B (10)   
* 128.0.0.0 ~ 191.255.255.255
> C (110)
* 192.0.0.0 ~ 223.255.255.255
> D    
* 224.0.0.0 ~ 239.255.255.255
> E    
* 240.0.0.0 ~ 247.255.255.255
> 기준값
* 127부터 64 / 32 / 16 / 8을 더함

DRM
---
> Clearing House    

> Contents Provider   

> Packager   

> Contents Distributor   

> DRM Controller   

> Security Container   

DFS
----
> 순회 기준 우선순위
* 자식, 형제, 상위

STACK
----
> 넘어가거나 없는데 포인트를 내리거나
* Overflow, Underflow
> Stack Guard   
* Stack을 이용하여 변조를 탐지, BOF공격 탐지

</br></br>

# 😃 데이터 베이스
</hr>

데이터베이스 설계
----
> 데이터베이스 설계 단계
* 개념 / 논리 / 물리 단계 
* 개념 스키마 / 인터페이스(논리적 스키마) / 트래픽 관련
* 뒤에 단계는 앞에 단계를 검증하는것을 포함할수있다

> 데이터 모델에 표시해야하는 요소
* 구조, 연산, 제약조건

E-R 다이어그램
----
> 사각형 / 마름모 / 타원 / 이중타원 / 밑줄 타원 / 복수타원 / 선
* Entity / Relaction / Attribute / 다중속성 / PK / 복합속성 / Link

DB SC 용어
----
> Degree   
> Cardinality   
> Tupel  
> Attribute      
> Domain    
> DISTINCT   
> JOIN   
> UNION   
> UNION ALL   
> INTERSECT   
> EXCEPT   
> CASCADE   
> RESTRICTED   
> View는 SQL의 제한이 있음   
* View로 인덱스 생성 불가
> 무결성과 기밀성
* 수정과 접근의 차이

병렬 데이터베이스 수평분할
---
> 데이터 튜닝기법
  * > 목록분할
    * 특정 칼럼을 기준으로 파티셔닝
  * > 조합분할
    * 여러가지를 조합하여(합성) 파티셔닝
  * > 해시분할
    * 해시 함수를 적용하여 파티셔닝
  * > 범위분할
    * 범위에 있는지 여부로 파티셔닝
  * > 라운드 로빈
    * 행의 고른 분포로 파티셔닝

정규화 과정
----
> 도메인이 원자값   
> 부분적 함수 종속 제거
* 부분키로도 특정이 가능하다면
> 이행적 함수 종속 제거 
* X->Y Y->Z라면   
> 결정자이면서 후보키 아닌것 제거   
> 다치 종속 제거   
> 조인 종속 제거   

추가개념
----
> 정규화된 속성을 단순화를 위해 중복을 통합하는 활동
* 반정규화 (집계 , 진행, 특정부분테이블을 추가)
> OLAP 
* 중앙화된 통합 데이터 저장소의 대용량 데이터를 분석하는 소프트웨어
* > 롤업(roll-up)
  * 작은 단위에서 큰 단위로 이동하는 연산(차원 낮추기)
* > 드릴다운(drill-down)
  * 큰 단위에서 작은 단위로 세분화, 롤업 프로세스의 반대(차원 높이기)
* > 슬라이스(slice, slicing)
  * 큐브의 한 조각을 연산, 큐브의 한 단면 보기(1개 차원 선택)
* > 다이스(dice, dicing)
  * 슬라이스와 비슷, 하위 큐브 만들기 위해 2개 이상 차원 선택
* > 피벗(pivot)
  * 데이터 축을 회전하여 제공
> STDDEV
* 표준편차
> VARIANCE
* 분산
> 분산데이터 특성
* Location / Replication / Failure / Concure


카티션 프로덕트
----
> 차수
* degree + degree
> 튜블
* cardinary * cardinary

접근통제 기술
----
> 임의    
* DAC, Discretionary Access Control
* GRANT , REVOKE가 예시
> 강제    
* MAC, Mandatory Access Control
> 역할기반    
* RBAC , Role Based Access Control

스토리지 시스템
----
> DAS
* Direct
> NAS
* Network
> SAN
* Nas + Das

관계대수
----
> 순수연산자
  * > Project (파이)
  * > Select (시그마)
  * > Join
  * > Devide (나누기)
  * > PROJECT, DIVISION 연산에 대해 설명
    * 칼럼만뗀냐, 해당 조건을 포함하는 (배제된) 칼럼 추출
> 연산이상현상  
  * > 삽입   
  * > 삭제   
  * > 갱신   
> 관계해석과의 차이
  * > 관계대수
    * How를 설명하는 절차언어
  * > 관계해석
    * What를 설명하는 비절차언어

정렬과 BIG(O)
----
> 버블
  * > 버블처럼 돌아가면서 계속 비교
    * n^2 / n^2
> 선택
  * > 1번째부터 이후인덱스들과 비교후 최소/최대값 추출후 교체
    * n^2 / n^2
> 삽입
  * > 2번째부터하나씩 빼서 이전인덱스와 비교해서 올바른 위치에 비교 삽입
    * n^2 / n
> 병합
  * > 반반씩 나누어서 비교후 합치기 (계속해서 나눔)
    * nLogN / nLogN
> 퀵
  * > pivot을 사용하여 분할정렬
    * nLogN / nLogN
> 기수정렬 
  * > 끝자리를 가지고 정렬
    * O(dN)
> 쉘정렬
  * > 삽입정렬을 발전시킨 방식
    * n^1.5 / n^2

모듈
----
> RPC
* Remote Procedure Call
> ORB
* Object Request Broker

> Tree 
* > Degree
  * 하위 노드가 가장 많이 달린수
* > 단말 노드
  * 하위가 없는 노드

</br></br>

# 😃 운영체재
</hr>

가상기억장치 구현
---
> 보조기억장치(하드디스크)를 주기억장치처럼 사용(RAM)
  * > 페이징
    * 내부단편화
    * 가상과 주기억을 동일하게 나눈뒤 적재
    * > 페이징맵 테이블 
      * 비용증가, 처리속도 느려짐
  * > 세그멘터이션
    * 외부단편화
    * 가상과 주기억을 논리적으로 나눈뒤 적재
    * 세그멘테이션 테이블

교착상태 조건
----
* 상호배제
* 점유와 대기
* 환형대기
* 비선점

프로세스 상태 순서
----
* Submit
* Hold
* Ready
* Run
* Wait
* Block
* Terminated

운영체재 자원 배분
---
> Best , Worst, First Fit의 정의   
* 어떻게 배치할 것인가
> 스레싱
* 프로레싱 처리기간보다, 쓰레드 배치 시간이 길어지면 나타나는 현상
* 페이지 부재가 많아짐
> 교착상태 해결법 
* > 예방
  * 교착상태 발생조건 제거(부정)
* > 회피
  * 은행원 알고리즘
* > 발견
  * 자원할당 그래프
* > 회복
  * 프로세스 자원 회복

> SecureOS
* 컴퓨터 사용자에 대한 식별 및 인증, 강제적 접근 통제, 임의적 접근 통제, 재사용 방지, 침입 탐지 등의 보안 기능 요소를 갖추어진 운영체제

> SSTF Scheduling   
* (Shortest Seek Time First) : 현재 디스크의 헤드 위치에서 가장 가까운 실린더에 대한 요청을 우선적으로 처리한다.
> HRN ( * Ratio * )
* Hightest Response-ratio Next (대기시간 + 서비스시간) / 서비스시간

페이지 교체 알고리즘
----
> FIFO
> OPT
* 가장 오래 사용하지 않은것 교체
> LRU
* Least Recently Used <> OPT
> LFU
* Least Frequenly Used
> MFU
* Most Frequenly Used

리눅스
----
> umask
* 초기 권한 설정값으로 파일은 666, 폴더는 777 에서 뺴는값
> 쉘스크립트 Export
* 환경변수를 설정
> fork
* 새로운 프로세스 생성
> fsck
* 파일시스템을 검사 / 보수
> netcat
* TCP 또는 UDP를 사용하여 네트워크 연결을 읽거나 기록하는 컴퓨터 네트워킹 유틸리티
> cron
* job scheduler
> SetUID
* 실 사용자에서 프로그램 소유자ID로 유효사용자가 변경됨 (권한 상승 우려 때문에 반드시 최소화해야함)

ISO 용어 정리
----
> ISO/IEC 25000
* 소프트웨어 품질 관련 국제 표준, 2501n은 외부 품질, 2502n은 내부 품질 기준
> ISO 12207와 SPICE 비교   
* https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=azurecourse&logNo=220041626265
* 소프트웨어 프로세스 능력 측정 국제표준

잊기 쉬운 짧은 개념들
----
> Hash함수
* 일방향 함수다.
* HAVAL , SHA-1
> 기수변환
* 다른 진법으로 간주하고 키를 변환하여 홈 주소를 얻는 방법
> 폴딩
* 키값을 여러부분으로 나눈후 각부분의 값을 더하거나 XOR연산후 주소
> CIDR 서브넷마스크 계산법
* /(1의 갯수) 와 옥텟을 기억
> 방식
* > 선형 탐사
  * 선형적으로 옮겨 액세스
* > 제곱 탐사
  * 제곱으로 이동해서 엑세스
* > 이중해싱
  * 규칙성을 없애버려서 클러스터링 방지
* > 전위식, 후위식
  * 연산가능한것을 해당방향으로 묶는것
* > 스키마 종류 (관점)
  * > 개념 스키마
    * 데이터 베이스의 전체적인 논리구조
  * > 내부 스키마
    * 데이터베이스의 물리적 저장구조를 정의
  * > 외부 스키마
    * 사용자나 응용프래그래머가 개인의 입장에서 필요한 데이터 베이스의 구조를 정의
> BaaS
* 서비스형 블록체인 (Blockchain as a Service)
> 스마트 그리드
* 전기 및 정보통신 기술을 활용하여 전력망을 지능화·고도화함으로써 고품질의 전력서비스를 제공하고 에너지 이용효율을 극대화하는 전력망
> 디지털 아카이빙
* 지속적으로 보존할 가치를 가진 디지털 객체를 장기간 관리하여 이후의 이용을 보장하는 활동
> Fcheck 
* 파일 시스템의 상태를 체크함으로써 간단히 파일 시스템의 무결성을 감시 한다
> 운행순서 (Root - order)
* preorder
* inorder
* postorder
> 디지털트윈
* 라이프사이클 전반에 걸쳐 실시간 데이터를 사용
* 시뮬레이션, 머신 러닝, 추론을 통해 의사 결정을 돕는 객체 또는 가상 모델
> Zing
* NFC에 사용되는 근거리 기술
> WPA
* Wi-Fi Protected Access
> 링크드 리스트
* 삽입, 삭제가 쉬운대신 검색속도가 오래걸림
> RDB
* 속석의 이름 / 속성의 값으로 튜플을 표현
* 튜플은 상이한것으로 정의내림
> cmp in C
* 비교하는 함수
> & in C
* 메모리의 주소를 의미
> ER Diagram의 이중속성과 기본키속성 표현방법   
> 리눅스 로그파일
* xferLog
* > wtmp
  * 성공한 로그인에 대한 로그
* > utmp
  * 현재 로그인 한 사람의 정보 로그
> 데이터 베이스의 투명성 목표
* A에 대하여 관계없이~~ -> A의 투명성
* 무엇에 대하여 관계없는지를 파악하는것이 중요
> 비트연산 기호
* ^ - XOR - 배타적 논리합(둘이 다르면 참) 
* ~ - NOR - Not OR   
> 암호화 방식 정리
* > 대칭키
  * 송수신자가 같은키를 가지고있어서 키교환이 가장 중요한부분
  * DES/ AES / SEED
* > 공개키
  * 대칭키 키교환문제 해결
  * 수신자의 공개키로 암호화
  * 당연히 수신자는 개인키로 복호화 가능
  * RSA
* > 개인키
  * 개인키로 암호화해도 누구나 공개키로 열수있다.
  * 보안이 중요한게 아니라 누가 암호화했는지를 정확히 알수있어서 인증에 사용된다.
  * 전자서명, 공인인증체계의 기초

</br></br>

# 😃 언어 개념 
</hr>

C언어 포인터 정리
----
> 연산자 우선순위 총정리
* 일단산비관트논조대콤
* 일차식, 단항, 산술, 비교, 관계, 비트, 논리, 조건, 대입, 콤마
* [](일차) , *(단항)
* 나머지는 넘기기
> 참조와 역참조
* *p *(*p)
* 역참조 할때마다 한단계 위로 올라간다고 생각하면 편함(다차원배열에서)
> 포인터 배열과 배열의 포인터
* int *p[3]
* int (*p)[3]
> 비트연산기호   
> 라이브러리   
> 함수정리
* > atoi
  * alphabet to integer
  * a (to) i 로 인지
* > atof , itoa, ceil... etc)
> sanf
* C언어의 표준 입력 함수
기타언어
----
> << 시프트 기호의 의미   
* 2진수를 하나밈 
> Scrapy
* 파이썬 기발 크롤링 프레임 워크
> 파이썬 슬라이스
* [초기:최종:증가값]
> @
* 오류제어 연산자

</br></br>

# 😃 보안과 오류 
</hr>

* 디버깅은 오류의 수정을 이야기함
> postfix
  * >  연산자가 피연산자 두개뒤에 놓이는 방식
      * Stack으로 연산

Buletooth Attack
----
> Bug 
* 원격조정, 전화, 감청
> narf (허겁지겁먹다)
* 파일에 접근
> Printing 
* 검색을 하는 활동
> Jacking 
* 명함을 익명으로 퍼뜨림

DOS
----
> smurfing (스머프??) 
* ICMP(error)를 활용하여 집중적으로 대용량 데이터 공격
> Ping of Death 
* 정상크기보다 큰 ICMP를 쪼개서 보내어 패킷을 처리하게 만듬
> SYN Flooding (Sync)
* 존재하지 않는 클라이언트가 접속하여 다른 사용자 사용불가능하게 만듬
> Land 
* 출발지와 목적지 IP를 동일하게 만듬
> Honeypot
* 비정상적인 접근 탐지
* 침입자를 속여 쉽게 공격이 가능한것처럼 보임
> DPI (Depp *)
* (Deep Packet Inspection) - 해킹 탐지, 트래픽 조정, OSI 전 레이어 탐지
> PLCP (Packet *)
* Packet Level Control Processor - 패킷 교환 시스템에서 정보 처리와 통계 등을 담당
> 암호화 알고리즘
* MD4, 5 (해시)
* SHA-1
* AES
* RSA


코드기입오류 정리
----
* Transcription
* Transposition
* Double Transposition
* Omission
* Addtion
* Random

SSH
----
  * > 기능   
  * > Default Port
    * 22
  * > 공개키 위치
    * SERVER
  * 원격명령, 쉘 서비스

암호화
----
> DES
* 64비트 알고리즘
> AES
* DES를 발전, 128비트 알고리즘
> RSA
* 소수로 암호화 비대칭 암호화
> 비대칭 알고리즘 공개키 / 비밀키 암호화 차이
* 공개키 - 신뢰단체라는것을 인증하는 관점
* 개인키 - 데이터를 안전하게 전송한다는 관점
> Authorization / Authentication
* 인가 / 인증

보안및 공격방식
----
> Secure 코딩
* 공격자가 프로그램 코드를 실행시키게 만드는 방식 - 작동이 목적임
> C&C Server   
* Command & Control 서버 
* 사이버 공격에서 두뇌 역할
> Botnet   
* 좀비 PC
> Zero Day Attack  
* 패치가 나오지 않은 시점에서 이루어지는 공격 
> Key Logger Attack   
* 컴퓨터 사용자의 키보드 움직임을 탐지해서 저장하고, ID나 패스워드, 계좌 번호, 카드 번호 등과 같은 개인 중요 정보를 몰래 빼가는 해킹
> Back Door
* 어떤 제품이나 컴퓨터 시스템, 암호시스템 혹은 알고리즘에서 정상적인 인증 절차를 우회하는 기법
> Brute-Force Attack   
* 암호학 무차별 대입공격
> Ping Flood   
* system에 ICMP packet을 계속해서 보내서, 대상 system이 Request 에 응답하느라 다른 일을 하지 못하도록 하는 공격
> Opcode   
* 기계어에서 명령코드를 나타내는 부호
> Salt  
* 데이터, 비밀번호, 통과암호를 해시 처리하는 단방향 함수의 추가 입력으로 사용되는 랜덤 데이터이다
> OWASP(Open *)   
* 오픈 소스 웹 어플리케이션 보안 프로젝트
* 가장 큰 오픈소스 웹 애플리케이션 보안 프로젝트
* 웹에 관한 정보노출, 악성 파일 및 스크립트, 보안 취약점 등을 연구
> Collision Domain   
* 동일한 collision domain에서 하나의 PC가 통신할 경우, 다른 모든 PC는 통신이 불가
> CSMA/CA  (A) 
* Carrier Sense Multiple Access / Collision Avoidance
* 반송파 감지 다중 엑세스 충돌 회피
> CSMA/CD  (D)
* Carrier Sense Multiple Access / Collision Detect
* 반송파 감지 다중 엑세스 충돌 감지
> DSA   
* DSA는 미국의 전자서명 표준이다.
> IPSec  
* 네트워크에서의 안전한 연결을 설정하기 위한 통신 규칙 또는 프로토콜 세트 
* 터널모드와 전송모드
* 전송모드는 헤더로르 제외한 페이로드만 보호
* 터널모드는 전체 패킷을 보호
> nmap  
* NMAP은 port Scanning 툴(해킹방어)
> 세션하이재킹
* 세션이 활성화된상태(로그인)을 가로채는것
* ACK Storm 탐지 , 비동기화상태 탐지, 패킷의 유실과 재전송증가탐지, 기대하지 않는 접속의 리셋 확인
> ACK Storm
* 세션하이재킹시에 패킷의 유실이 많이 일어나는데, 이때 패킷량이 비정상적으로 재전송이 일어나면서 증가하는 현상
> SMTP (Simple Mail)
* 간이 우편 전송 프로토콜(Simple Mail Transfer Protocol)의 약자로, 이메일 전송에 사용되는 네트워크 프로토콜이다.
> S-HTTP
* S-HTTP는 웹상에서 네트워크 트래픽을 암호화하는 주요 방법 중 하나이다. 
* 웹상에서 네트워크 트래픽을 암호화하는 것에는 주로 2가지 방법을 사용하는데 한 가지는 S-HTTP 이고 다른 하나는 SSL이다.
> ESB (Enterprise * Bus)
* 표준화된 메시지 버스와 프로토콜을 이용해서 서로 연동할 수 있는 시스템
> Pharming
* 피싱(가짜)사이트로 유도, 금융정보를 탈취하여 유출된 정보로 예금인출하는 방식
> Trin00
* trinoo 또는 trin00은 DDoS 공격을 수행하기 위한 일련의 컴퓨터 프로그램

<br/>   

기타 외워야하는 Service및 기술들
----
> Stacheldraht
* 분산서비스 거부공격을 하는 멜웨어
> TFN(* Network)
* Tribe Flood Network
* 다양한 DDoS 공격을 수행하는 컴퓨터 프로그램 집합
> Nimda
* 님다는 2001년 9월에 발생한 컴퓨터 바이러스이다
> PIMS(Personal Information *)
* Personal Information Management System
* 기업이 개인정보 보호 활동을 체계적, 지속적으로 수행하기 위해 점검하여 일정 수준 이상의 기업에 인증을 부여하는 제도
> QKD(Quantum *)
* Quantum Key Distribution 
* 양자 물리학의 기본 원리를 활용하여 검증 가능한 보안으로 광섬유 네트워크를 통해 암호화 키를 교환하는 기술
> Grayware
* 사용자의 동의를 받아 다운받는 (불편함을 유발) 프로그램 - adware가 속함
> Mashup
* Web info -> new System
> 타조   
* 하둡(Hadoop) 기반의 분산 데이터 웨어하우스 프로젝트
> 원세그
* 일본의 이동방송 기술   
> 포스퀘어   
* 위치 기반 소셜 네트워크 서비스이자 이를 개발한 회사의 명칭
> ASLR  
* Address Space Layout Randomization
* 주소 공간 배열 무작위화. 말 그대로 주소를 매번 실행할 때마다 무작위화시켜 공격을 방해 
> Sqoop 
* Hadoop과 관계형 데이터베이스 간에 데이터를 전송할 수 있도록 설계된 오픈소스 소프트웨어  
> N-Screen   
* 특정한 주제의 콘텐츠들을 여러 개의 스크린에서 동시에 볼 수 있다는 개념
> Memristor   
* Memory registor (이전의 상테를 기억하는 메모리)
> MEMS   
* Micro Electro Mechanical Systems (미세 전기 기계 시스템)의 약자
* 미세한 입체 구조 (3차원 구조)를 지니며, 다양한 입력 · 출력 신호를 취급하는 시스템의 총칭
> evil twin attack
* 로그온한 사람들을 속이고 비밀번호나 신용카드 번호를 훔치기 위해 합법적인 네트워크인 것처럼 가장한 무선 네트워크
> phisihing
* 컴퓨팅에서 피싱(phishing)은 전자우편 또는 메신저를 사용해서 신뢰할 수 있는 사람 또는 기업이 보낸 메시지인 것처럼 가장
* 비밀번호 및 신용카드 정보와 같이 기밀을 요하는 정보를 부정하게 얻으려는 소셜 엔지니어링
> cyberbulling
* 특정 메신저에 특정 학생을 초대해서 단체로 괴롭히는 행동
> tripwire
* 먼저 시스템에 존재하는 파일에 대해 데이터 베이스를 만들어 저장한 후 생성된 데이터베이스와 비교
* 추가·삭제되거나 변조된 파일이 있는지 점검하고 관리자에게 레포팅해주는 무결성 검사도구
> MapReduce
* 필터링과 정렬을 거쳐 데이터를 추출(Reduce)하는 분산처리 기술과 관련된 Framework를 의미
>  NS Chart
* http://itnovice1.blogspot.com/2019/08/nsnassi-schneiderman.html