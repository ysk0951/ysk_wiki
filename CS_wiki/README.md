#  Computer Sciense Dictionary

## Section : 프로그래밍 언어 활용

#### 공통
프로그래밍 언어 주요개념
----
> for ( a= 0 ; a < 10 ; ++a, hap +=a ) 
* for문에서 3번째 증가항에 ,으로 구분된 동작을 넣으면 순서대로 실행된다 (후위연산 마감처리)
> 선언형 알고리즘
* 수행해야할 문제를 기술, 알고리즘은 명시하지 않음
> 우선순위가 같을때
* 좌에서 우로 계산
> ~ 연산 총정리
* 숫자를 반전시킴 
* 원래수를 구하려면 2의 보수를 구하면된다
* 그수의 부호반대값이 원래 숫자
> 2의 보수의 개념
* 더하면 0이 되는수
> 소수구하는 알고리즘   
* 2부터 판별하는 수 전까지 나눠보고 나머지가 0이 안나온다면 소수로 정의
> 피보나치 알고리즘
* 값을 누적한뒤 전항을 치환하는 방식
> 제곱근 함수
* Math.sqrt
> 비트연산 개념및 우선순위
* &
* ^ (다르다)
* |
* ~ (반전)
> 진수표현
* 8진수 - 앞에 0
* 16진수 - 뒤에 0x
> 헷갈리는 연산
* > %
  * 나머지
* > //
  * 몫
* > &
  * 주소값
* 후위연산은 연산이 완료된 뒤에 반영되기때문에 무시한다
* 전위연산이여도 도달하지 못함 스코프는 무시한다
> 서식문자열
* > 8자리 확보, 4글자를 오른쩍에서부터 출력
  * %8.4s
* > 정수
  * %d, %i
* > 실수
  * %f 
> 서버용 스크립트 언어
* PHP
> C언어의 모체가된 언어
* ALGOL

#### JAVA
----
* > 오버라이딩시 주의점
  * super를 언급하지 않으면 자식메소드를 호출
* 싱글톤 변수는 instance화 해도 공유됨

#### Python
----
> Scrapy
* 파이썬 기발 크롤링 프레임 워크
> 파이썬 슬라이스
* [초기:최종:증가값]
> True 대소문자 구분함
* While(True):
> Range 의 영역
* -1 영역까지
> range(8,0,-1)
* 8부터 0번인덱스까지 1씩 감소시키면서 진행

#### C언어
----
> 입력예제
* scanf(“%d”, &num[I])
> 참조와 역참조
* *p *(*p)
> 다차원배열에서 포인터
* 역참조 할때마다 한단계 위로 올라간다고 생각
> 포인터 배열과 배열의 포인터
* int *p[3]
* int (*p)[3]
> 라이브러리   
> 함수정리
* > atoi
  * alphabet to integer
  * a (to) i 로 인지
* > atof , itoa, ceil... etc
> C의 bool타입 값
* 0,1

## Section : 응용SW 기초 기술활용
> 윈도우 특징 5가지 
* [POS2선]
* Plug and Play
* OLE (object linking and Embedding)
* Single User 시스템
* 255자의 긴 파일명
* 선점형 멀티태스킹

#### 페이지 교체 알고리즘
> 최소 
* Least
> 빈도 
* Frequently
> 최근 
* Recently
----
> 가장먼저들어온걸 교체   
* FIFO
> 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 알고리즘 (실제로는 거의 구현불가, 연구용으로 쓰임)
* OPT   
> 가장오랫동안 사용하지 않은 페이지 교체
* LRU - Least Recently Used
> 가장 적게 참조된 페이지를 교체
* LFU - Least Frequenly Used (참조에 의미)
> MFU
* Most Frequenly Used
> Best , Worst, First Fit의 정의   
* 어떻게 배치할 것인가
> 프로레싱 처리기간보다, 쓰레드 배치 시간이 길어지면서 페이지 부재가 나타나는 현상
* 스레싱

> 가상메모리
  * > 페이징
    * 내부단편화
    * 가상과 주기억을 동일하게 나눈뒤 적재
    * > 페이징맵 테이블 
      * 비용증가, 처리속도 느려짐
  * > 세그멘터이션
    * 외부단편화
    * 가상과 주기억을 논리적으로 나눈뒤 적재
    * 세그멘테이션 테이블

#### 프로토콜 (9의시)
----
> 데이터의 형식, 부호
* 구문
> 정확한 정보전송을 위한 협조사항과 제어
* 의미
> 통신속도와 메세지 순서제어
* 시간

#### 명령어 정리
----
> chmod
* 사용자 그룹 기타
* chmod 775 file.txt
> 소유자
* chown user12 media.txt
> 초기 권한 설정값으로 파일은 666, 폴더는 777 에서 뺴는값
* umask
> 환경변수를 설정
* 쉘스크립트 Export
> 새로운 프로세스 생성
* fork
> 파일시스템을 검사 / 보수
* fsck
> TCP 또는 UDP를 사용하여 네트워크 연결을 읽거나 기록하는 컴퓨터 네트워킹 유틸리티
* netcat
> cron
* job scheduler
> SetUID
* 실 사용자에서 프로그램 소유자ID로 유효사용자가 변경됨 (권한 상승 우려 때문에 반드시 최소화해야함)
> 운영체재 성능평가 기준 (사신처반)
* > 즉시 사용가능한 정도
  * 사용가능도
* > 문제를 정확히 해결하는 정도
  * 신뢰도
* > 시스템이 처리하는 양
  * 처리능력
* > 의뢰시간부터 처리완료시간까지 걸리는시간 (대기시간 포함)
  * 반환시간
> 가상기억장치 국부성
* 시간 구역성
* 공간 구역성

#### 스케쥴링
----
> 비선점
* 프로세스를 빼앗지못함
> 실행시간이 가장 짧은 스케쥴링
* SJF 스케줄링(Shortest Job First Scheduling)
* FCFS 스케줄링(First Come First Served Scheduling)
* HRRN 스케줄링(Highest Response Ratio Next Scheduling)
> 선점
* 프로세스를 빼앗음
* RR 스케줄링(Round Robin Scheduling)
* SRTF 스케줄링(Shortest Remaining-Time First Scheduling)
* 다단계 큐 스케줄링(Multilevel Queue Scheduling)
* 다단계 피드백 큐 스케줄링(Multilevel Feedback Queue Scheduling)
* RM 스케줄링(Rate Monotonic Scheduling)
* EDF 스케줄링(Earliest Deadline First Scheduling)
> 현재 디스크의 헤드 위치에서 가장 가까운 실린더에 대한 요청을 우선적으로 처리
* SSTF Scheduling   
> HRN 
* Hightest Response-ratio Next 
* (대기시간 + 서비스시간) / 서비스시간
</br>

> 한 PC에게만 보내는 1:1 형대
* 유니캐스트 
> 도메인 안에있는 모든 PC들에게 보내는 형태
* 브로드 캐스트
> 원하는 그룹에게만 보내는방식
* 멀티캐스트
> 가장가까운 Node에게 보내는 방식
* 애니캐스트
> IPv6 개념
* 16bit씩 8부분
* 16진수로 표현하고 콜론으로 구분
* 40옥텟 해더

> IPv4 Class 정리
> A (0)   
* 0.0.0.0 ~ 127.255.255.255
> B (10)   
* 128.0.0.0 ~ 191.255.255.255
> C (110)
* 192.0.0.0 ~ 223.255.255.255
> D    
* 224.0.0.0 ~ 239.255.255.255
> E    
* 240.0.0.0 ~ 247.255.255.255
> 기준값
* 127부터 64 / 32 / 16 / 8을 더함
> 서브넷팅
* 할당된 네트워크를 다시 작은 여러 네트워크로 나누는것

> IP to MAC Address (Address Resolution Protocol) 프로토콜
* ARP(Address * *)
> Internet Control Message Protocol
* ICMP (* Message Protocol)
> 각각 서버와 클라이언트가 둘다 될수있는 방식(Point to Point)의 프로토콜
* Point to Point
> TCP/UDP
* 차이는 연결형 / 비연결형 으로 속도와 신뢰성의 문제
> OSI 2계층은 인접하는 신뢰, 종단간은 신뢰는
* 4계층
> OPI 계층
* > 하드웨어 전기신호 변환 
  * 물리
* > 물리계층 신뢰도 보장
  * 데이터 링크 
* > 라우터, IP지정
  * 네트워크 
* > TCP의 주요 프로토콜은 FTP
  * 전송
* > 세션
  * 세션계층
* > 암복호화
  * 표현
* > 표현 어플리케이션 계층
  * 응용

#### 네트워크 장비정리
----
> 신호증폭
* 리피터
> 최적의 경로 선택기능 추가
* 라우터
> 네트워크 출입구
* 게이트웨이
> LAN끼리 연결하여 병목현상 제거
* 브릿지
> 가상회선 방식 연결형 서비스 (연결이 더 김)
* TCP
> 데이터그램 비연결형 서비스
* IP

#### 통신망 구성형태
----
> 중간단말
* 계층형
> 중앙집중식
* 성형
> 모든 단말 연결
* 망형
* 회선수 n(n-1)/2 
* 포트수 n-1
> Peir to Peir
* 링형
> 한회선에 여러단말
* 버스형

#### 기타 기술
----
> 센서를 통해 정보를 인식, 수집 관리
* 유비쿼터스 센서 네트워크
> 유비쿼터스 공간 구현을 위한 지능 통신
* IOT
> IGP의 한계를 극복, 네트워크 변화가 있을때만 갱신, 다익스트라 알고리즘 사용
* OSPF
* Open Shortest Path First
> 수신측의 확인신호를 받지 않더라도 정해진 패킷수를 연속으로 전송
* 슬라이딩 윈도우
> 소스 프로그램과 정보를 제3의 기관에 보관
* 소프트웨어 에스크로
> 차세대 지능형 웹
* 시멘틱 웹
> 사용자의 동의를 받아 다운받는 불편함을 유발 하는 프로그램
* Grayware
> 신개념 플래시 웹 페이지 제작 기술
* 리치 인터넷 어플리케이션
> 애플리케이션을 일반 구역과 보안구역으로 분할하여 관리
* 트러스트존 
> 센서, 액추에이터 기반 초정밀 반도체 기술을 바탕으로한 초미세 장치
* MEMS
> 메타 데이터    
> 기존 데이터에 소비자와의 상호작용을 통해 새로운 가치가 더해진 데이터
* 브로드 데이터

## Section : SQL
DDL
----
> CREATE SCHEMA 이름 AUTHORIZATION ID     
> CREATE DOMAIN 이름 AS 데이터타입 DEFAULT CONSTRAINT     
> CREATE INDEX ON 테이블명       
> VIEW (삽입 연산 뷰 정의조건)
* CREATE VIEW 이름 AS 쿼리 WITH 체크옵션
* CREATE VIEW 3학년 학생(강좌명, 학점, 학기) AS SELECT * FROM 학생 WITH CHECK OPTION     
> TABLE 
* CREATE TABLE 직원 ()
> ALTER 
* ALTER TABLE 학생 ADD 주소 CHAR(20);
* ALTER TABLE 학생 DROP 주소 
> DROP 
* DROP TABLE 직원;

DCL
----
> GRANT
* GRANT 권한 ON 어디에 TO 누구에게
* GRANT ALL ON 학생 TO 홍길동 WITH GRANT OPTION;
* REVOKE SELECT ON 교수 FROM 박문수 CASCADE; (연쇄삭제)
> ROLLBACK
* ROLLBACK TO S2;

DML
----
> INSERT
* INSET INTO 테이블 VALUES();
> DELETE
* DELETE FROM 상품 WHERE 제품코드 = "P-20"
> UPDATE SET
> SELECT
* [SELECT] [PREDICATE] table [OPTIONS]
* > LIKE PATTERN
  * _ , %
* > GROUP Function (COUNT, SUM, AVG)
  * SELECT AVG(장학금) FROM 장학금 GROUP BY CUBE(장학내역, 학과);
* > UNION, UNIONALL, INTERSECT, EXCEPT
  * 집합연산자
* > JOIN
  * OUTER - 만족하지 않아도 출력
  * INNER - 만족해야 출력

> 트리거
  * create or replace trigger insipgo  
  * after insert on 입고
  * for each row
  * begin update 상품 set 재고수량 = 재고수량 +:NEW.입고수량
  * where 상품코드 = :NEW.상품코드;
  * end;

## Section : 애플리케이션 테스트 관리
> 검증 테스트
* 개발자 시각
> 확인테스트
* 사용자 시각
> 정적 테스트
* 워크스루
* 인스펙션
> 동적 테스트
* [동시분경]
* 동등분할
* 시나리오 테스트
* 분류 트리 기법
* 경계값 분석
</br>

화이트박스 테스트
----
> 문장 
* 소스코드의 모든 구문이 한번 이상 수행
> 분기
* 모든 조건문에 대한 조건식 테스트 케이스 설계
> 조건
* 개별 조건문에 대한 조건식 테스트 케이스 설계 

#### 테스트 분류
----
> 올바르게 복구
* 회복
> 침입으로 부터 보호
* 안전
> 과부화
* 강도
> 실시간 성능, 효율성
* 성능
> 내부의 논리적인 경로, 소스코드의 복잡도
* 구조
> 수정된 코드 결함없음
* 회귀
> 동일한 데이터 입력, 결과비교
* 병행

#### 생명주기 V모델
----
> 요구사항에 대한 테스트
* 인수 테스트
> 분석에 대한 테스트
* 시스템 테스트
> 설계에 대한 테스트
* 통합 테스트
> 구현에 대한 테스트
* 단위 테스트
</br>

> 비점진적 통합테스트
* 빅뱅 통합테스트
> 점진적 통합테스트
* > 상향식
  * 하위모듈을 클러스터로 결합
  * 드라이버 작성
  * 클러스터 검사
  * 드라이버를 제거하고 클러스터를 상위로 결합
* > 하향식
  * 하위모듈 스텁으로 대체
  * 회귀 테스트 실시
* 혼합식
> 스텁이란?
* 서버가 구현, 하위모듈을 대체
* 하향식 통합테스트, 정해진 객체 결과값을 서버에 전달
> 태스트 드라이버란?
* 클라이언트가 구현, 상향모듈을 대체
* 인자값을 넘겨주는 상향식 통합테스트

#### 테스트 오라클 
----
> 모든 케이스에 대해서 전수테스트
* 참 오라클
> 특정 입력값들에 대해서만 원하는 결과제공
* 샘플링 오라클
> 샘플링 오라클 개선, 참이 아닌 결과값은 휴리스틱(직관)처리
* 휴리스틱 오라클 
> 이전 수행결과와 현재 수행결과가 동일한지 검증
* 일관성 검사 오라클

> 테스트가 실행될 환경을 시뮬레이션 하여 컴포넌트와 모듈 테스트
* 테스트 하네스
* 하네스의 구성요소로 드라이버와 스텁이 있음
> 결함 분류 
* 시기지문
* 시스템
* 기능
* GUI
* 문서

> 애플리케이션 성능 측정 지표 
* [자처응경]
* 자원사용률
* 처리량
* 응답시간
* 경과시간 (처리가 완료될때까지만 측정)

> 클린 코드 작성원칙
* [추가의 중단]
* 추상화
* 가독성
* 의존성 배제
* 중복성 최소화
* 단순성

## Section : 소프트웨어 개발 보안 구축

### 암호 알고리즘 

#### 양방향
----
> 비공개키(대칭키)   
* 송수신자가 같은키
* Stream , Block 방식
* DES/ AES / SEED
> 공개키(비대칭키)
* > Public으로 암호화
  * 대칭키 키교환문제 해결
  * 수신자의 공개키로 암호화
  * 당연히 수신자는 개인키로 복호화 가능
  * RSA
* > Private으로 암호화
  * 개인키로 암호화해도 누구나 공개키로 열수있다.
  * 보안이 중요한게 아니라 누가 암호화했는지를 정확히 알수있어서 인증에 사용된다.
  * 전자서명, 공인인증체계의 기초

#### 단방향
----
* 해싱
> 64비트 알고리즘
* DES
> DES를 발전, 128비트 알고리즘
* AES
> 소수로 암호화 비대칭 암호화
* RSA

### 기타 보안개념
----
> 보안 요소
* > 인가된 자만 수정
  * 무결성
* > 인가된 자만 접근허용
  * 기밀성
* > 인가된 자는 언제라도 사용가능
  * 가용성
* > 사용자가 합법적인 사용자인지 확인
  * 인증
* > 송수신 부인할수없도록 증거 제공
  * 부인방지
> SDLC(소프트웨어 개발 생명주기)에다가 보안강화 프로세스를 포함한것(Secure Coding)
* Secure SDLC
> 구현단계에서 발생할수있는 취약점을 최소하 하기 위한 코딩
* Secure Coding
> AAA Server
* > Authentication 
  * 접근사용자의 신원검증
* > Authorization 
  * 신원검증된 사용자게에 서비스 허용
* > Accounting 
  * 사용자의 기록을 보관

Bluetooth Attack
----
> 원격조정, 전화, 감청
* Bluetooth Bug 
> 파일에 접근
* Bluetooth narf (허겁지겁먹다)
> 검색을 하는 활동
* Bluetooth Printing 
> 명함을 익명으로 퍼뜨림
* Bluetooth Jacking 
> ICMP(error)를 활용하여 집중적으로 대용량 데이터 공격
* smurfing 
> 정상크기보다 큰 ICMP를 쪼개서 보내어 패킷을 처리하게 만듬
* Ping of Death 
> 존재하지 않는 클라이언트가 접속하여 다른 사용자 사용불가능하게 만듬(Sync)
* SYN Flooding 
> 출발지와 목적지 IP를 동일하게 만듬
* Land 
> 침입자를 속여 쉽게 공격이 가능한것처럼 보임
* Honeypot
> 해킹 탐지, 트래픽 조정, OSI 전 레이어 탐지
* DPI 
> 패킷 교환 시스템에서 정보 처리와 통계 등을 담당
* PLCP(Packet Level Control Processor)
> C&C Server   
* Command & Control 서버 
* 사이버 공격에서 두뇌 역할
> 좀비 PC
* Botnet   
> 패치가 나오지 않은 시점에서 이루어지는 공격 
* Zero Day Attack  
> 저장하고, ID나 패스워드, 계좌 번호, 카드 번호 등과 같은 개인 중요 정보를 몰래 빼가는 해킹
* Key Logger Attack   
> 어떤 제품이나 컴퓨터 시스템, 암호시스템 혹은 알고리즘에서 정상적인 인증 절차를 우회하는 기법
* Back Door
> 암호학 무차별 대입공격
* Brute-Force Attack   
> system에 ICMP packet을 계속해서 보내서, 대상 system이 Request 에 응답하느라 다른 일을 하지 못하도록 하는 공격
* Ping Flood   
> 기계어에서 명령코드를 나타내는 부호
* Opcode   
> 데이터, 비밀번호, 통과암호를 해시 처리하는 단방향 함수의 추가 입력으로 사용되는 랜덤 데이터
* Salt  
> 오픈 소스 웹 어플리케이션 보안 프로젝트
* OWASP
> 미국의 전자서명 표준이다
* DSA   
> IPSec  
* 네트워크에서의 안전한 연결을 설정하기 위한 통신 규칙 또는 프로토콜 세트 
* 터널모드와 전송모드
* 전송모드는 헤더로르 제외한 페이로드만 보호
* 터널모드는 전체 패킷을 보호
> port Scanning 툴(해킹방어)
* nmap  
> 세션이 활성화된상태(로그인)을 가로채는것
* 세션하이재킹
> ACK Storm
* 세션하이재킹시에 패킷의 유실이 많이 일어나는데, 이때 패킷량이 비정상적으로 재전송이 일어나면서 증가하는 현상
> SMTP 
* 간이 우편 전송 프로토콜
> 웹 상에서 네트워크 트래픽을 암호화하는 주요 방법
* S-HTTP
> 표준화된 메시지 버스와 프로토콜을 이용해서 서로 연동할 수 있는 시스템
* ESB
> 피싱(가짜)사이트로 유도, 금융정보를 탈취하여 유출된 정보로 예금인출하는 방식
* Pharming
> DDoS 공격을 수행하기 위한 일련의 컴퓨터 프로그램
* Trin00
> 방화벽 + 침입탐지 시스템
* IPS
* Intrusion Prevention System
> 사내직원의 내부정보 외부유출을 방지하는 솔루션
* DLP
* Data Loss Prevention
> 사용자가 자신의 전용회선을 사용하는것처럼 해주는 보안 솔루션
* VPN
> NAC (* Access *)
* 네트워크 접근제어(Network Access Control)
* 인가된 장치만이 네트워크에 접속할 수 있도록 제한하는 것

## Section : 서버프로그램 구현
> 하드웨어환경
* Web Server
* WAS
* DB Server
* File Server
> 웹서버기능
* [대가인H]
* 대역폭제한
* 가상 호스팅
* 인증
* HTTPS
> 개발언어 선정기준 5가지
* 범용성
* 친밀성
* 효율성
* 이식성
* 적정성
> 아키텍처 설계과정
* 설게 목표설정
* 시스템 타입 결정
* 아키텍처 패턴 적용
* 서브시스템 구체화
* 검토
> 아키텍처 품질평가 3요소
* 시스템(기능)
* 비즈니스
* 아키텍처(무결성품질)
> 컴포넌트 설계시 클래스에 대한 여러 가정을 공유하도록 명세
* 협약 설계 
> 협약 설계 조건
* 선행조건
* 결과조건
* 불변조건
> 레이어 패턴   
> 클라이언트-서버 패턴    
> 파이프-필터 패턴    
> 모델뷰컨트롤러 패턴    
> 마스터-슬레이브 패턴   
> 브로커 패턴   
* 서버와 클라이언트 사이에 브로커(Dispatcher) 라는 서비스 컴포넌트를 두어서, 실제 패킷이 해당 컴포넌트를 거쳐서 가게 
> 피어투피어 패턴   
* 서로 누구나 클라이언트, 서버가 될수있는 패턴
> 이벤트 버스 패턴   
* listerner / subscribe 형태
> 블랙보드 패턴   
* 공유 데이터 저장소와 블랙보드 컴포넌트에 모든 컴포넌트가 접근가능한 패턴
> 인터프리터 패턴   
> 객체지향 주요개념
* 클래스
* 메세지
* 캡슐화
* 상속
> 다형성
* 하나의 메세지에 대해 고유한 방법으로 응답
* > 연관성
  * > 연관화
    * is member of 
  * > 분류화
    * is instance of
  * > 집단화
    * is part of
  * > 일반화
    * is a
> 럼바우 분석
* > 객체모델링
  * 객체다이어그램 이용
* > 동적모델링
  * 상태다이어그램 이용
* > 기능모델링
  * 자료흐름도를 이용
> SOLID (LS/IS/DI)
* Single responsibility principle
> O
* Open-close principle
* 확장에는 열려있어야 하고, 변경에는 닫혀 있어야 함
> L
* Liskov substitution principle : super()
* 상위 타입 객체를 하위 타입 객체로 치환해도 정상적으로 동작해야 함
> I
* Interface segregation principle
* 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원리
> D
* Dependency inversion principle
* 위계 관계 역전 불가
* Dependency : child -> parent
* 구체화된 클래스에 의존하기 보다는 추상 클래스나 인터페이스에 의존해야 한다는 뜻


### 객체지향 설계분석론   
-----
> Wrfs-Block
* 분석과 설계의 구분없이 고객명세서부터 설계작업까지 연속적 수행을 하는 설계론
> Rumhaugh
* 객체, 동적, 기능순으로 분석하는 분석론
> Booch
* Micro와 Macro로 나눠서 분석하는 방식
> Jacobson
* UseCase로 분석하는 방식
> Coad-Yorudon
* E-R 다이어그램을 사용하여 객체 행위 모델링을 통해 분석하는 방식

### 좋은소프트웨어
-----
> 응집도 순서
* > 기능 요소들이 연관되어 수행될때의 응집도
  * 기능적
* > 모듈내의 활동으로 나온 [출력데이터를 그 다음 활동]으로 사용할 경우 응집도
  * 순차적 
* > 동일한 입력과 출력을 사용하여 서로다른 기능을 수행하는 구성요소들이 모였을 경우 응집도 
  * 통신적
* > 모듈안의 구성요소들이 기능을 [순차적으로] 수행할 경우 응집도
  * 절차 
* > 특성 시간에 처리되는 기능이 모여 응집
  * 시간 
* > 논리 
* > 어떤 의미도 없이 연관관계가 없는것
  * 우연 

> 결합도 순서 
* > 내부 자료를 직접참조
  * 내용
* > 공통 데이터 영역을 여러 모듈이 사용
  * 공통
* > 외부의 다른모듈에서 참조
  * 외부
* > 논리적인 흐름을 제어하기 위해 제어신호나 제어요소를 전달하는 결합도
  * 제어
* > 인터페이스로 배열이나 레코드 등의 자료구조가 전달되는 결합도
  * 스탬프 
* > 인터페이스가 자료 요소로만 구성될때의 결합도
  * 자료

> FanIn/ FanOut 
* 모듈의 수를 의미
> 단위모듈
* 독립적인 컴파일 가능, 다른모듈에 삽입되거나 호출될수도있음
* 한가지 동작을 수행하는 기능을 모듈로 구성
> 테스트 케이스
* 테스트 항목에 대한 명세서
> 모듈간 통신방식을 구현하기위해 사용되는 대표적인 프로그래밍 인터페이스 집합
* IPC (3SPM)
* > 대표메소드
  * > Shared Memory
    * 공유메모리를 구성
  * > Socket
    * 네트워크 소켓을 이용
  * > Semaphores
    * 공유자원 접근제어
  * > Pipes & named Pipes
    * Pipe라고 불리는 FIFO 메모리를 공유하여 통신
  * > Message Queueing
    * 메세지가 발생하면 이를 전달

> 공통모듈 명세기법
* 재사용
* > 일관성 
  * 공통 기능간 상호충돌이 발생하지 않아야함
* 완전성
* 정확성
* 명확성
* > 추적성 
  * 관련 시스템 관계 파악이 가능해야함

### 코드의 종류
----
> 1,2,3,4
* 순차 코드 (일렬번호 코드)
</br>

> 1001~1100 1101~1200
* 블록 코드 (구분 코드)
</br>

> 1000 : 공학, 1100 소프트웨어 공학 , 1110 소프트웨어 설계
* 10진 코드
</br>

> 1-01-001 : 본사
* 그룹 분류 코드
</br>

> TV-40 : 40인치 TV
* 연상 코드 (연상가능, 연상 < 표의)
</br>

> 120-720-1500 : 120x720x1500 인 강판
* 표의 코드 (깊이, 넓이, 부피를 그대로 적용 - 유효 숫자 코드)
</br>

> 연상 + 숫자 KE-711 : 대한항공 711기
* 합성 코드

#### 🍎 GoF 디자인패턴의 종류
----
> 생성의 네가지 종류  
* 팩토리 , 빌더 , 프로토 , 싱글톤
* > 팩토리   
  * > 인터페이스
    * 추상팩토리  
  * > 객체 생성을 서브클래스에서
    * 팩토리 메소드 
* > 인스턴스의 조합
  * 빌더
* > 원본객체를 복사
  * 프로토
* > 싱글톤 
</br>

> 구조
* > 호환성 없는 클래스들을 이용할수 있도록 변환
  * 어뎁터
* > 구현부에서 추상층 분리, 독립적 확장
  * 브릿지
* > 객체간의 결합을 통해 능동적으로 기능확장
  * 데코레이터
* > 접근하기 어려운 객체에 연결
  * 프록시
* > 복합객체, 단일객체 구분없이 사용
  * 컴포지트
* > 복잡한 서프클래스를 피해 더 상위 인터페이스
  * 퍼싸드
* > 인스턴스를 가능한한 공유해서 씀
  * 플라이웨이트
</br>

> 행위
* > 객체가 둘 이상 존재하면, 한객체가 처리하지 못할시에 다음으로 넘어가는 패턴
  * 책임연쇄
* > 변화하는 상태를 전달
  * 옵저버
* > 객체의 상태값에 따라서 동일한 동작을 다르게 처리
  * 상태
* > 🔥 데이터 구조에서 처리기능을 분리, 별도의 클래스로 구성하는 패턴
  * 방문자
* > 🔥 요청을 객체의 형태로 캡슐화 하고, 로그에 남기는 패턴
  * 커맨드
* > 🔥 언어에 문법 표현을 정의
  * 인터프리터
* > 🔥 동일한 인터페이스를 사용
  * 반복자
* > 🔥 수많은 객체간의 복잡한 상호작용을 캡슐화
  * 중재자
* > 특정 시점의 객체 내부상태를 객체화
  * 메멘토
* > 동일계열 알고리즘을 개별적으로 캡슐화
  * 전략
* > 🔥 상위 클래스에서 골격을 정의, 하위클래스에서 세부처리
  * 템플릿메소드
> IDEA
* JetBrains에서 만든 멀티 플랫폼 IDE
> 빌드도구
* Ant
  * 아파치 재단에서 개발한 자바의 공식빌드 도구
* > Maven
  * 아파치 재단에서 Ant 대안으로 개발
* Gradle
  * 한스 도커가 개발, 안드로이드 스튜디오의 공식 빌드 도구
> 배치프로그램 필수요소 (대자견안성)
* 대용량 데이터
* 자동화
* 견고성
* 안전성/신뢰성
* 성능

> 배치프로그램
* Spring Batch
* Quartz (오픈소스,작업과 시간관리 요소 분리)
* Cron
> Crontab
* 분 시 일 월 요일 명령어
* 미지정시 에스테리크 표시(*)

## Section : 데이터 입출력 구현
> DBMS 정의
* 데이터베이스를 관리하는 소프트웨어
> DBMS 기능 카테고리
* 정의
* 조작
* 제어
> 스키마의 3가지 명세종류
* 외부(사용자입장)
* 내부(물리적장치입장)
* 개념(전체구조)
> DB설계순서
* 요구조건분석
* 개념
* 논리(스키마)
* 물리(테이블)
* 구현

#### 데이터모델
----
> 표시요소
* 구조 연산 제약조건
> 개체(대상체)
* 속성
* 튜플
* 스키마
* 인스턴스-튜플의 집합
> 속성(논리적단위)
* 기본
* 설계-원래는 없으나 설계중 도출
* 파생-다른속성의 변형을 받아 발생되는 속성
> 관계
* 중복 
* 종속
* 재귀
* 배타-분할

#### 키개념
----
> 후보키
* 유일성,최소성
> 슈퍼키
* 유일성만
> 기본키    
> 대체키
* 후보키중 기본키가 아닌것
> 외래키   
</br>

> Cardinality(*), Degree(+)
> DB정규화
* > 1정규화 
  * 도 메인이 원자값
* > 2정규화 
  * 부 분적 함수종속 제거
* > 3정규화 
  * 이 행적 함수종속 제거
* > BCNF 
  * 결 정자가 후보키이면서
* > 4정규화 
  * 다 치종속 제거
* > 5정교휴 
  * 조 인종속 제거
> 논리 물리데이터 변환 (SSE)
* 슈퍼타입
* 서브타입
* 개별타입
> 관계대수(How, 절차언어)
* > 순수관계연산
  * Join
  * Division
  * Project
  * Select
  * DIVISION을 꼭 기억 https://velog.io/@khs0415p/8-%EA%B4%80%EA%B3%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%97%B0%EC%82%B0
> 반정규화     
> 트랜잭션 특징
* 원자성
* 독립성
* 일관성
* 영속성
> 조인등을 통하여 새로운 테이블을 자유로이 유도하고싶을때
* 뷰
> <키 값, 포인터> 쌍으로 구성되는 데이터 구조
* 인덱스
> 데이터 분산은 파티션
* 파티션
> 분산데이터 목표
* 위중병장
* 위치
* 중복
* 병행
* 장애
* ~가 일어나더라도 유지
> 접근통제 
* > Discretionary Access Control 
  * 신원에 근거
* > Mandatory Access Control 
  * 강제접근통제
* > Role Based Access Control  
  * 역활기반
> 스토리지 3가지
* DAS
* NAS
* SAN
> 방향그래프 최대간선수
* 방향(n/n-1)
* 비방향 (n/n-1)/2
> 트리의 차수와 단말노드
* 차수는 자식이 최대인 노드의 자식수
* 단말노드는 하위노드가 없는 노드의 수
> 트리 순서
* L -> R이고 Root를 개념에 따라 놓음
> 중위식 전위식 후위식 계산     
> 삽입, 선택, 버블정렬, 기수정렬 계산     

## Section : 통합구현 [85%]
> 통합구현의 구성요소
* 송수신시스템모듈
* 중계시스템
* 연계데이터
* 네트워크
> 연계 데이터 식별및 표준화 절차
* 항목정의
* 코드 변환 및 매핑
* 데이터 식별자 ,변경구분 추가 
* 데이터 표현방법정의
* 데이터 명세서작성
> 연계 매커니즘 구성
* 데이터생성, 추출 
* 코드 매핑
* 인터페이스 테이블 또는 파일 생성
* 로그 기록
* 어뎁터로 전송
* 운영DB에 반영
> 연계 장애대응
* 장애, 오류관리 대상정의
* 오류코드 메시지 정의
* 메세지 관리방식 정의
* 장애로그 설계
> 연계 데이터 보안(암복호화)
* 암호화 키 선정
* 암호화 적용 대상 컬럼 데이터 길이번경(평문보다 길어짐)
* 암복호화 진행

#### XML
----
> XML 교환 통신규약
* SOAP
* Simple Object Access Protocol
> XML로 작성되는 웹서비스 서식
* WSDL
* Web Services Description Language
</br>

## Section : 요구사항 확인
> 소프트웨어 생명주기의 정의
* 소프트웨어를 개발하기 위해 설계, 운용, 유지보수 과정을 단계별로 나눈것
> 소프트웨어 개발방법론의 4가지 정의
* 폭포수
* 프로토타입 
* > 나선형
  * 계획수립
  * 위험분석
  * 개발및 검증
  * 고객평가
* > 애자일
  * 스크럼
  * XP
  * 칸반
  * Lean
  * FDD
> 오픈소스    
> 스크럼 프로세스 5단계
* 스프린트 계획 
* 스프린트 
* 일일 스크럼 회의 
* 스프린트 검토 
* 스프린트 회고
> XP 핵심가치 5가지
* 단순
* 의사소통
* 용기
* 존중
* 피드백
> XP 실천방법 6가지
* Whole Team
* Pair Programming
* Collective Ownership
* TDD
* Refactoring
* Continuous Intergration
* Small Release
> 개발환경 파악
* 가용성
* 성능
* 기술지원
* 구축비용
* 주변기기 / 상호호완성
> 요구사항 개발 프로세스 4단계
* 도출
* 분석
* 명세
* 확인
> 요구사항의 분류
* 비기능요구사항
* 기능요구사항
* 사용자요구사항
* 시스템요구사항   
> 요구사항 명세 분류
* > 정형요구사항 명세
  * 수학
* > 비정형 요구사항 명세    
  * 자연어
> 분석단계의 구조적 분석방법중 DFD 기본구성 4가지
* Process
* DataFlow
* Data Stroe
* Terminator
> 분석단계의 구조적 분성방법중 DD 기본구성 6가지
* 정의 = 
* 생략 ()
* 선택 []
* 반복 {}
* 생략 **
> 분석단계의 자동화 도구 (CASE)
* 요구사항을 자동으로 분석, 명세서를 기술하는 도구
> 분석단계의 HIPO차트의 3가지 도구
* 가시적
* 세부적
* 총체적
> UML 관계의 화살표 모양정리
* 연관
* 일반화
* 실체화
* 의존 - 의존이 좀 독특
* 집합
* 포함
> 클래스안에 {}를 이용하는것은 무엇인가
* 제약조건
> 연관클래스의 개념
* 연관관계에 있는 두 클래스에 추가로 표현해야할 속성이나 오퍼레이션이 있는 경우 생성하는 클래스
> 스테레오 타입
* include : 포함되어서 수행
* extend : 선택적 수행
> 활동 다이어그럄 구성요소
* 액션
* 시작, 종료노드
* 조건, 병합노드
* 포크, 조인노드
* 스웜레인
> 순차 다이어그램 구성요소
* 프레임
* 액터
* 객체
* 활동상자
* 생명선
* 메세지
> 소프트웨어 재사용
* > 합성중심
  * 블록을 조립
* > 생성중심
  * 명세를 구채화
> 델파이 기법     
> COCOMO 세가지 유형   
* LOC에 의한 비용산정 기법
* 조직
* 반분리
* 내장
> FP의 정의       
> PUTNAM의 특징    
* 노력곡선 분포도
> 비용산정 자동화 도구 
* PSFE
* PUTNAM, FP
* SLIM, ESTIMACS
> PERT의 CPM의 차이, 그리고 간트차트
* 기간 예측이 어려운경우 일정은 PERT
* 작업 소요시간이 있을시에는 CPM
* 임계는 최대값을 선정
* 막대 도표를 이용하는 시간선 차트는 간트
> CMMI 조직성숙도 단계
* 초기
* 관리
* 정의
* 정량
* 최적화
> 테일러링
* > 내부적기준    
* > 외부적기준
  * 법적제약
  * 표준풉질기준
> SPICE의 수행능력 6단계    
* 불완전 
* 수행 
* 관리 
* 확립 
* 예측 
* 최적화
> SPICE의 프로세스 범주
* 고객공급자 (전달)
* 공학 (명세화, 유지보수)
* 지원 (다른프로세스에 의해 이용)
* 관리 (관리자에 의해 사용)
* 조직 (조직업무 목표달성)
> 개발프레임워크특성
* 모듈화
* 재사용성
* 확장성
* 제어의 역흐름

## Section : 화면설계
> 사용자 인터페이스 구분
* CLI, GUI, NUI
> NUI
* > Pan   
  * Touch, Hold, Move
* > Flick   
  * Quickly Brush
* > Pinch   
  * Touch surface with Two Fingers and bring then closer or apart

> 기본원칙
* 직관성
* 유효성
* 학습성
* 유연성

> 와이어프레임 
* 레이아웃만
> 목업 
* 실제화면 정적형태
> 스토리보드 
* 와이어 프레임에 페이지간 이동흐름, 컨텐츠 설명 추가
> 프로토타입    
* 실제 구현도니것처럼 테스트 가능한 모형

> UI 설계 순서
* 요구사항 확인
* UI 구조 설계
* 메뉴 구조(사이트맵) 설계
* 화면 설계

> UX특징
* 주관성
* 정황성
* 총체성

## Section : 인터페이스 구현
> 인터페이스 검증
* 동료검토
* > 워크스루
  * 명세서를 미리 배포하여 사전검토후 검토회의
* > 인스펙션
  * 작성자를 제외한 다른 검토 전문가들이 명세서 확인
> 인터페이스 요구사항 검증항목
* 완전성
* 일관성
* 명확성
* 기능성
* 검증 가능성
* 추적 가능성
* 변경 용이성

> 송수신 데이터 식별
* 인터페이스 표준항목
* 송수신 데이터 항목
* 공통 코드

> 인터페이스 표준 항목
* > 시스템 공통부
  * 시스템 연동시 필요한 공통 정보
* > 거래 공통부
  * 연동된후 송수신데이터 처리시 필요한 정보

> 명세화 하기 필요한 정보
* 시스템 연계 기술
* 인터페이스 통신 유형
* 처리 유형
* 발생 주기

> 인터페이스 처리 유형
* 실시간
* 지연 처리
* 배치

> 시스템 연계 기술
* DB Link
* Api
* 연계 솔루션
* Socket

> 주요 미들웨어
* > RPC
  * Remote Procedure Call
* > MOM
  * 메세지 지향 미들웨어(비동기형 메세지를 전달하는 미들웨어)
* > TP-Monitor
  * 트랜잭션 처리 모니터
* > ORB
  * CORBA 표준 스펙을 구현한 객체 지향 
* > WAS
  * 동적인 콘텐츠를 처리하기 위한 미들웨어

> EAI
* > Point to Point
  * 1:1로 연결함, 변경및 재사용이 어려움
* > Hub & Spoke
  * 중앙 집중형 방식
* > Message Bus
  * 애플리케이션 사이에 미들웨어를 두어 처리하는 방식
* > Hybrid
  * Hub와 Message Bus의 혼합

> ESB
* EAI와 유사하지만 에플리케이션 보다는 서비스 중심의 통합

> 웹 서비스
* 서비스 지향 아키텍처(SOA) 개념 실현 대표적인 방법
* > SOAP
  * XML 기반의 프로토콜
* > UDDI
  * WSDL을 등록하여 서비스와 서비스 제공자를 검색하고 접근하는데 사용됨
* > WSDL
  * XML로 작성되며, UDDI의 기초가됨

> 인터페이스 데이터 표준
* 모듈간 인터페이스에 사용되는 데이터 형식을 표준화하는것

> 인터페이스 기능 구현 절차
* > 컴포넌트 명세서 확인
  * 컴포넌트의 개요및 내부클래스의 동작등, 인터페이스를 통해 외부와 통신하는 명세등을 정의
* > 인터페이스 명세서 확인
  * 컴포넌트 명세서의 항목중 인터페이스 클래스의 세부조건 및 기능 정의
* 인터페이스 기능 구현 정으
* 정의된 인터페이스 기능구현 정형화

> 인터페이스 엔티티를 이용한 인터페이스 구현
* 인터페이스 엔티티를 이용
* 일반적으로 인터페이스 테이블을 엔티티로 활용

> 데이터 무결성 검사도구
* Tripwire
* AIDE
* Samhain
* Claymore
* Slipwire
* Fcheck

> 인터페이스 구현 검증 도구   
* > xUnit
  * 단위테스트가 핵심   
* > TAF (* Automation *)  
  * > Test Automation Framwork
    * STAF, NTAF
    * 컴포넌트및 서비스 테스트 자동화가 핵심
* > FitNesse
  * Test Wiki
* > watir
  * Ruby Test

> 인터페이스 보안 기능
* > 네트워크 영역
  * IPSec, SSL, S-HTTP
* > 애플리케이션 영역   
  * 애플리케이션 코드상의 보안 취약점을 보완하는 방식
* > 데이터베이스 영역
  * 동작 객체의 보안취약점에 보안 기능을 적용

> APM
* 애플리케이션 성능관리 모니터링 도구
* 리소스방식
* > 앤드투엔드 방식
  * > 스카우터
    * OS 자원 모니터링
  * > 제니퍼
    * 테스트, 오픈, 운영 전단계 성능 모니터링

## Section : 제품소프트웨어 패키징
> DRM
  * > 클리어링 하우스
    * 저작권 사용권한, 라이센스 발급
  * 콘텐츠 제공자
  * 패키져
  * 콘텐츠 분배자
  * 콘텐츠 소비자
  * > DRM 컨트롤러
    * 배포된 콘텐츠 이용권한 통계 프로그램
  * > 보안 컨테이너
    * 원본 보안 장치
> DRM관련기술
  * 암호화 
  * 키관리
  * 암호화 파일 생성
  * 식별 기술
  * 저작권 표현
  * 정책 관리
  * 크랙 방지
  * 인증
> 패키징 순서
  * 기능식별
  * 모듈화
  * 빌드
  * 사용자 환경분석
  * 패키징 적용
  * 패키징 개선
  * 배포
> 릴리즈 노트
  * 개발자와 사용자의 의사소통
> 설치 메뉴얼
  * 기능식별
  * UI 분류
  * 설치파일 확인
  * Uninstall 절차 확인
  * 이상케이스 확인
  * 최종메뉴얼
> IGP (Interior *)
  * > Interior Gateway Protocol (동일그룹)
  * > OSPF (* Shortest *)
    * Open Shortest Path First
  * > RIP (* imfomation *)
    * > Routing Infomation Protocol
      * Hop Counting
> EGP   
  * > Exterior Gateway Protocol (외부그룹)
> BGP   
  * > Boarder Gateway protocol (종속 게이트웨이)
> 흐름제어
* 정지대기
* 슬라이딩 윈도우
> 교착상태 조건
* 상호배제
* 점유와 대기
* 환형대기
* 비선점
> 교착상태 해결법 
* > 예방
  * 교착상태 발생조건 제거(부정)
* > 회피
  * 은행원 알고리즘
* > 발견
  * 자원할당 그래프
* > 회복
  * 프로세스 자원 회복
<br/>
<br/>
<br/>


## 나머지 개념들
> PMD (* mistacke *)
* PMD(Programming Mistake Detector)
* 응용 프로그램 코드에서 발견 된 문제를 보고 하는 오픈 소스 정적 Java 소스 코드 분석기
> cppcheck
* Cppcheck는 크로스 플랫폼(윈도우, 데비안, 페도라, 맥 등)을 지원하며, 개발IDE에 플러그인으로 연동할 수 있습니다
> sonarQube
* 정적 코드 분석으로 코드 품질 검사용 오픈 소스 플랫폼
> ccm (* complicated *)
* 다양한 언어의 복잡도 분석
> cobertuna
* 자바 언어의 소스코드 복잡도 분석 및 테스트 커버리지 측정
> FTR (Formal Technical Review)
* 검토에만 집중하기 위해, 검토 이외의것을 모두 제한하는 방식(논쟁,인원 등등)
> Revese Engineering
* 일반적인 개발 단계와는 반대로 기존 코드를 복구하거나 소프트웨어 관계를 추출하는 방식
> Alien Code
* 참고문서와 관리하는 개발자가 없어 유지보수가 어려운 프로그램 코드
> 화이트박스 검사, 블랙박스 검사
* 실행 경로의 기초(내부적)를 정의하는 검사와, 내부를 보지않고 입력과 출력에 중점을 둔 검사의 차이
> 알파테스트 , 베타테스트
* 내부테스트(개발진, QA) , 상용테스트(일반인)   
> FAT -> NTFS
* 상대적 대용량, 대신 속도가 늘려짐 
> VLAN   
* 논리적으로 분할된 스위치 네트워크 : 동적인 조직에서 작업 그룹을 구성할 수 있음
> STP (* Tree *)
* Spannging Tree Protocol
* 2개 이상의 스위치가 여러 경로로 연결될때, 무한 루프 현상을 막기 위해 우선순위에 따라 1개로 통신하는 프로토콜
> L2AN
* OSI의 2계층에 속하는 장비
* MAC 주소를 기반으로 프레임을 전송하고 동일 네트워크 간의 연결만 가능
> SDS (Software *)
* Software Defined Storage 
* 스토리지를 가상화하여 여러 스토리지를 하나처럼 관리하거나, 여러 스토리지로 나눠 사용하는 소프트웨어
> SDDC (* data Center)
* Software-defined Data Center 
* 데이터센터의 모든 인프라인 네트워크, 스토리지, 컴퓨터, 보안 등이 가상화 되어 제공되는 데이터센터 솔루션
> MLFQ (Multi level *) 
* Multi-level Feedback Queue - MLFQ는 여러 개의 큐로 구성되며, 각각 다른 우선순위(Priority level)가 배정된다. 
* 실행 준비가 된 프로세스는 이 중 하나의 큐에 존재한다. MLFQ는 실행할 프로세스를 결정하기 위하여 우선순위를 사용한다. 
* 높은 우선순위를 가진 작업, 즉 높은 우선순위 큐에 존재하는 작업이 선택된다. 
> MQTT (Message * Transport)
* Message Queuing Telemetry Transport 
* 경량 머신 대 머신 통신에 사용되는 표준 기반 메시징 프로토콜
* 발행 - 구독 기반의 메세징 프로토콜
> Zingbee   
* 소형, 저전력 디지털 라디오를 이용해 개인 통신망을 구성하여 통신하기 위한 표준 기술
> MBR(master *)   
* master boot record - 파티션된 기억 장치(이를테면 하드 디스크)의 첫 섹터 (섹터 0)인 512 바이트 시동 섹터이다   
> NIC(* interface *)
* 네트워크 인터페이스 컨트롤러(network interface controller, NIC)
* 네트워크에 연결하여 통신하기 위해 사용하는 하드웨어 장치
> Topology   
* 단어 그 자체로 망 구성방식
* 컴퓨터 네트워크의 요소들(링크, 노드 등)을 물리적으로 연결해 놓은 것, 또는 그 연결 방식
> SNMP (Simple Network *)
*  UDP/IP(사용자 데이터그램 프로토콜/인터넷 프로토콜)를 사용하여 이더넷 연결을 통해 네트워크 관리 작업을 수행하는 응용 계층 프로토콜 
> FLSM (Fixed Length *)
* Fixed Length Subnet Mask  <-> VariableLength Subnet Mask
> ARQ (* Request)
* ARQ는 Automatic Repeat Request
* 에러가 발생할 경우 재전송을 요구하는 방식이다. 
> Wi-Sun
* Wireless Smart Utility Network
* 일본에서는 특정 소전력 무선으로 일컬어지는 920MHz 대에서 사용
> Sliding Window
* 일단 '윈도(메모리 버퍼의 일정 영역)'에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인되는대로 이 윈도를 옆으로 옮김(slide)으로서 그 다음 패킷들을 전송하는 방식
> GPIB(* Purpose Interface *)
* General Purpose Interface Bus
* PC를 통하여 계측기나 기타 장비 등 표준 프로토콜로 병렬 및 고속 제어하기 위하여 사용
> 병렬 데이터베이스 수평분할   
> 데이터 튜닝기법
  * > 목록분할
    * 특정 칼럼을 기준으로 파티셔닝
  * > 조합분할
    * 여러가지를 조합하여(합성) 파티셔닝
  * > 해시분할
    * 해시 함수를 적용하여 파티셔닝
  * > 범위분할
    * 범위에 있는지 여부로 파티셔닝
  * > 라운드 로빈
    * 행의 고른 분포로 파티셔닝
> OLAP 
* 중앙화된 통합 데이터 저장소의 대용량 데이터를 분석하는 소프트웨어
* > 롤업(roll-up)
  * 작은 단위에서 큰 단위로 이동하는 연산(차원 낮추기)
* > 드릴다운(drill-down)
  * 큰 단위에서 작은 단위로 세분화, 롤업 프로세스의 반대(차원 높이기)
* > 슬라이스(slice, slicing)
  * 큐브의 한 조각을 연산, 큐브의 한 단면 보기(1개 차원 선택)
* > 다이스(dice, dicing)
  * 슬라이스와 비슷, 하위 큐브 만들기 위해 2개 이상 차원 선택
* > 피벗(pivot)
  * 데이터 축을 회전하여 제공
> 분산데이터 특성
* Location / Replication / Failure / Concure
> 프로세스 상태 순서
* Submit
* Hold
* Ready
* Run
* Wait
* Block
* Terminated
> SecureOS
* 컴퓨터 사용자에 대한 식별 및 인증, 강제적 접근 통제, 임의적 접근 통제, 재사용 방지, 침입 탐지 등의 보안 기능 요소를 갖추어진 운영체제


#### ISO 용어 정리
----
> ISO/IEC 25000
* 소프트웨어 품질 관련 국제 표준, 2501n은 외부 품질, 2502n은 내부 품질 기준
> ISO 12207와 SPICE 비교   
* https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=azurecourse&logNo=220041626265
* 소프트웨어 프로세스 능력 측정 국제표준

#### 잊기 쉬운 짧은 개념들
----
> Hash함수
* HAVAL , SHA-1
> 기수변환
* 다른 진법으로 간주하고 키를 변환하여 홈 주소를 얻는 방법
> 폴딩
* 키값을 여러부분으로 나눈후 각부분의 값을 더하거나 XOR연산후 주소
> CIDR 서브넷마스크 계산법
* /(1의 갯수) 와 옥텟을 기억
> 방식
* > 선형 탐사
  * 선형적으로 옮겨 액세스
* > 제곱 탐사
  * 제곱으로 이동해서 엑세스
* > 이중해싱
  * 규칙성을 없애버려서 클러스터링 방지
* > 전위식, 후위식
  * 연산가능한것을 해당방향으로 묶는것
* > 스키마 종류 (관점)
  * > 개념 스키마
    * 데이터 베이스의 전체적인 논리구조
  * > 내부 스키마
    * 데이터베이스의 물리적 저장구조를 정의
  * > 외부 스키마
    * 사용자나 응용프래그래머가 개인의 입장에서 필요한 데이터 베이스의 구조를 정의
> BaaS
* 서비스형 블록체인 (Blockchain as a Service)
> 스마트 그리드
* 전기 및 정보통신 기술을 활용하여 전력망을 지능화·고도화함으로써 고품질의 전력서비스를 제공하고 에너지 이용효율을 극대화하는 전력망
> 디지털 아카이빙
* 지속적으로 보존할 가치를 가진 디지털 객체를 장기간 관리하여 이후의 이용을 보장하는 활동
> Fcheck 
* 파일 시스템의 상태를 체크함으로써 간단히 파일 시스템의 무결성을 감시 한다
> 운행순서 (Root - order)
* preorder
* inorder
* postorder
> 디지털트윈
* 라이프사이클 전반에 걸쳐 실시간 데이터를 사용
* 시뮬레이션, 머신 러닝, 추론을 통해 의사 결정을 돕는 객체 또는 가상 모델
> Zing
* NFC에 사용되는 근거리 기술
> WPA
* Wi-Fi Protected Access
> 링크드 리스트
* 삽입, 삭제가 쉬운대신 검색속도가 오래걸림
> RDB
* 속석의 이름 / 속성의 값으로 튜플을 표현
* 튜플은 상이한것으로 정의내림
> cmp in C
* 비교하는 함수
> & in C
* 메모리의 주소를 의미
> ER Diagram의 이중속성과 기본키속성 표현방법   
> 리눅스 로그파일
* xferLog
* > wtmp
  * 성공한 로그인에 대한 로그
* > utmp
  * 현재 로그인 한 사람의 정보 로그
> 데이터 베이스의 투명성 목표
* A에 대하여 관계없이~~ -> A의 투명성
* 무엇에 대하여 관계없는지를 파악하는것이 중요
> 비트연산 기호
* ^ - XOR - 배타적 논리합(둘이 다르면 참) 
* ~ - NOR - Not OR   
> SSH
  * > 기능   
  * > Default Port
    * 22
  * > 공개키 위치
    * SERVER
  * 원격명령, 쉘 서비스

<br/>   

#### 기타 외워야하는 Service및 기술들
----
> Stacheldraht
* 분산서비스 거부공격을 하는 멜웨어
> TFN(* Network)
* Tribe Flood Network
* 다양한 DDoS 공격을 수행하는 컴퓨터 프로그램 집합
> Nimda
* 님다는 2001년 9월에 발생한 컴퓨터 바이러스이다
> PIMS(Personal Information *)
* Personal Information Management System
* 기업이 개인정보 보호 활동을 체계적, 지속적으로 수행하기 위해 점검하여 일정 수준 이상의 기업에 인증을 부여하는 제도
> QKD(Quantum *)
* Quantum Key Distribution 
* 양자 물리학의 기본 원리를 활용하여 검증 가능한 보안으로 광섬유 네트워크를 통해 암호화 키를 교환하는 기술
> Mashup
* Web info -> new System
> 타조   
* 하둡(Hadoop) 기반의 분산 데이터 웨어하우스 프로젝트
> 원세그
* 일본의 이동방송 기술   
> 포스퀘어   
* 위치 기반 소셜 네트워크 서비스이자 이를 개발한 회사의 명칭
> ASLR  
* Address Space Layout Randomization
* 주소 공간 배열 무작위화. 말 그대로 주소를 매번 실행할 때마다 무작위화시켜 공격을 방해 
> Sqoop 
* Hadoop과 관계형 데이터베이스 간에 데이터를 전송할 수 있도록 설계된 오픈소스 소프트웨어  
> N-Screen   
* 특정한 주제의 콘텐츠들을 여러 개의 스크린에서 동시에 볼 수 있다는 개념
> Memristor   
* Memory registor (이전의 상테를 기억하는 메모리)
> MEMS   
* Micro Electro Mechanical Systems (미세 전기 기계 시스템)의 약자
* 미세한 입체 구조 (3차원 구조)를 지니며, 다양한 입력 · 출력 신호를 취급하는 시스템의 총칭
> evil twin attack
* 로그온한 사람들을 속이고 비밀번호나 신용카드 번호를 훔치기 위해 합법적인 네트워크인 것처럼 가장한 무선 네트워크
> phisihing
* 컴퓨팅에서 피싱(phishing)은 전자우편 또는 메신저를 사용해서 신뢰할 수 있는 사람 또는 기업이 보낸 메시지인 것처럼 가장
* 비밀번호 및 신용카드 정보와 같이 기밀을 요하는 정보를 부정하게 얻으려는 소셜 엔지니어링
> cyberbulling
* 특정 메신저에 특정 학생을 초대해서 단체로 괴롭히는 행동
> tripwire
* 먼저 시스템에 존재하는 파일에 대해 데이터 베이스를 만들어 저장한 후 생성된 데이터베이스와 비교
* 추가·삭제되거나 변조된 파일이 있는지 점검하고 관리자에게 레포팅해주는 무결성 검사도구
> MapReduce
* 필터링과 정렬을 거쳐 데이터를 추출(Reduce)하는 분산처리 기술과 관련된 Framework를 의미
>  NS Chart
* http://itnovice1.blogspot.com/2019/08/nsnassi-schneiderman.html
