#  Computer Sciense Dictionary

## Chapter 01
> 소프트웨어 생명주기의 정의
* 소프트웨어를 개발하기 위해 설계, 운용, 유지보수 과정을 단계별로 나눈것
> 소프트웨어 개발방법론의 4가지 정의
* 폭포수
* 프로토타입 
* 나선형
* 애자일
> 스크럼 프로세스 5단계
* 스프린트 계획 
* 스프린트 
* 일일 스크럼 회의 
* 스프린트 검토 
* 스프린트 회고
> XP 핵심가치 5가지
* 단순
* 의사소통
* 용기
* 존중
* 피드백
> XP 실천방법 6가지
* Whole Team
* Pair Programming
* Collective Ownership
* TDD
* Refactoring
* Continuous Intergration
* Small Release
> 개발환경 파악
* 가용성
* 성능
* 기술지원
* 구축비용
* 주변기기 / 상호호완성
> 요구사항 개발 프로세스 4단계
* 도출
* 분석
* 명세
* 확인
> 요구사항의 분류
* 비기능요구사항
* 기능요구사항
* 사용자요구사항
* 시스템요구사항   
> 요구사항 명세 분류
* > 정형요구사항 명세
  * 수학
* > 비정형 요구사항 명세    
  * 자연어
> 분석단계의 구조적 분석방법중 DFD 기본구성 4가지
* Process
* DataFlow
* Data Stroe
* Terminator
> 분석단계의 구조적 분성방법중 DD 기본구성 6가지
* 정의 = 
* 생략 ()
* 선택 []
* 반복 {}
* 생략 **
> 분석단계의 자동화 도구 (CASE)
* 요구사항을 자동으로 분석, 명세서를 기술하는 도구
> 분석단계의 HIPO차트의 3가지 도구
* 가시적
* 세부적
* 총체적
> UML 관계의 화살표 모양정리
* 연관
* 일반화
* 실체화
* 의존 - 의존이 좀 독특
* 집합
* 포함
> 클래스안에 {}를 이용하는것은 무엇인가
* 제약조건
> 연관클래스의 개념
* 연관관계에 있는 두 클래스에 추가로 표현해야할 속성이나 오퍼레이션이 있는 경우 생성하는 클래스
> 스테레오 타입에서 include, extend를 설명
* include : 포함되어서 수행
* extend : 선택적 수행
> 🔥 활동 다이어그램 구성요소
* 프레임
* 액터
* 객체
* 활동상자
* 생명선
* 메세지
> 델파이 기법     
> LOC 세가지 유형   
* 조직
* 반분리
* 내장
> FP의 정의
> PUTNAM의 특징    
* 노력곡선 분포도
> 비용산정 자동화 도구 (PUTNAM, FP)
* SLIM, ESTIMACS
* PSFE
> PERT의 CPM의 차이, 그리고 간트차트
* 기간 예측이 어려운경우 일정은 PERT
* 작업 소요시간이 있을시에는 CPM
* 임계는 최대값을 선정
* 막대 도표를 이용하는 시간선 차트는 간트
> SPICE의 수행능력 6단계    
* 불완전 
* 수행 
* 관리 
* 확립 
* 예측 
* 최적화
> SPICE의 프로세스 범주
* 고객공급자 (전달)
* 공학 (명세화, 유지보수)
* 지원 (다른프로세스에 의해 이용)
* 관리 (관리자에 의해 사용)
* 조직 (조직업무 목표달성)

## Chapter 02
> DBMS 정의
* 공동으로 사용
* 쉽게처리
* 저장장치에 저장
> DBMS 기능 카테고리
* 정의
* 조작
* 제어
> 스키마의 3가지 명세종류
* 외부(사용자입장)
* 내부(물리적장치입장)
* 개념(전체구조)
> DB설계순서
* 요구조건분석
* 개념
* 논리(스키마)
* 물리(테이블)
* 구현
> 데이터모델 구성요소
* 개체(대상체)
* 속성(논리적단위)
* 관계
> * 개체의 분류
  * 속성
  * 튜플
  * 스키마
  * 인스턴스-튜플의 집합
> * 속성의 분류
  * 기본
  * 설계-원래는 없으나 설계중 도출
  * 파생-다른속성의 변형을 받아 발생되는 속성
> * 관계의 정리
  * 중복 
  * 종속
  * 재귀
  * 배타-분할
> 키개념
* > 후보키
  * 유일성,최소성
* > 슈퍼키
  * 유일성만
* > 기본키    
* > 대체키
  * 후보키중 기본키가 아닌것
* 외래키
> Cardinality(*), Degree(+)
> DB정규화
* > 1정규화 
  * 도 메인이 원자값
* > 2정규화 
  * 부 분적 함수종속 제거
* > 3정규화 
  * 이 행적 함수종속 제거
* > BCNF 
  * 결 정자가 후보키이면서
* > 4정규화 
  * 다 치종속 제거
* > 5정교휴 
  * 조 인종속 제거
* https://code-lab1.tistory.com/48
> 논리 물리데이터 변환
* 슈퍼타입
* 서브타입
* 개별타입
> 관계대수(How, 절차언어)
* > 순수관계연산
  * Join
  * Division
  * Project
  * Select
* 각각의 기호와 개념
> 반정규화    
> 트랜잭션 특징
* 원자성
* 독립성
* 일관성
* 영속성
> 뷰와 인덱스, 파티션    
* 뷰는 조인등을 통하여 새로운 테이블을 자유로이 유도하고싶을때   
* 인덱스는 <키 값, 포인터> 쌍으로 구성되는 데이터 구조
* 데이터 분산은 파티션
> 분산데이터 목표   
* 위치
* 중복
* 병행
* 장애
* ~가 일어나더라도 유지
* 분산설계(위치분산 -> 분할 -> 할당)
> 접근통제
* DAC
* MAC 
* RBAC
> 접근통제 3요소 
* 정책, 메커니즘, 보안모델
> 스토리지 3가지
* DAS, NAS, SAN
> 방향그래프 최대간선수
* 방향(n/n-1)
* 비방향 (n/n-1)/2
> 트리의 차수와 단말노드
* 차수는 자식이 최대인 노드의 자식수
* 단말노드는 하위노드가 없는 노드의 수
> 트리 순서
* L -> R이고 Root를 개념에 따라 놓음
> 중위식 전위식 후위식 계산     
> 삽입, 선택, 버블정렬, 기수정렬 계산     

## Chapter 03
> 통합구현의 구성요소
* 송수신시스템모듈
* 중계시스템
* 연계데이터
* 네트워크
> 연계 데이터 식별및 표준화 절차
* 연계 [항목정의]
* 연계 [코드] 변환 및 매핑
* 연계 데이터 [식별자],변경구분 추가 
* 연계 데이터 [표현방법정의]
* 연계 데이터 [명세서작성]
> 연계 매커니즘 구성
* 연계 [데이터생성], 추출 
* [코드] 매핑
* [인터페이스] 테이블 또는 파일 생성
* [로그] 기록
* [어뎁터]로 전송
* [운영DB]에 반영
> 연계 장애대응
* 장애, 오류관리 대상정의
* 오류코드 메시지 정의
* 메세지 관리방식 정의
* 장애로그 설계
> 연계 데이터 보안(암복호화)
* 암호화 알고리즘, 키 선정
* 암호화 적용 대상 컬럼 데이터 길이번경(평문보다 길어짐)
* 암호화 알고리즘 라이브러리 설치
* 암복호화 진행
> XML관련
* SGML개선 언어, SOAP는 XML 교환 통신규약
* WSDL(웹서비스 서식, 프로토콜 표준방법 기술 언어)은 XML로 작성

## Chapter 04 
> 하드웨어환경
* Web Server
* WAS
* DB Server
* File Server
> 웹서버기능(정적 서버)
* HTTPS
* 대역폭제한
* 가상 호스팅
* 인증
> 개발언어 선정기준 5가지
* 적정성
* 효율성
* 이식성
* 친밀성
* 범용성
> 소프트웨어 아키텍처
* 소프트웨어 구성관계를 표현하는 구조체
> 추상화
* 과정 추상화 (수행과정)
* 데이터 추상화
* 제어 추상화 (이벤트)
> 아키텍처 설계과정
* 설게 목표설정
* 시스템 타입 결정
* 아키텍처 패턴 적용
* 서브시스템 구체화
* 검토
> 아키텍처 품질평가 3요소
* 시스템(기능)
* 비즈니스
* 아키텍처(무결성품질)
> 협약 설계 
* 컴포넌트 설계시 클래스에 대한 여러 가정을 공유하도록 명세
* 선행조건
* 결과조건
* 불변조건
> 레이어 패턴   
> 클라이언트-서버 패턴   
> 파이프-필터 패턴   
> 모델뷰컨트롤러 패턴
> 마스터-슬레이브 패턴   
> 브로커 패턴   
> 피어투피어 패턴   
* 서로 누구나 클라이언트, 서버가 될수있는 패턴
> 이벤트 버스 패턴   
* listerner / subscribe 형태
> 블랙보드 패턴   
* 공유 데이터 저장소와 블랙보드 컴포넌트에 모든 컴포넌트가 접근가능한 패턴
> 인터프리터 패턴   
> 객체지향 주요개념
* 클래스
* 메세지
* 캡슐화
* 상속
> 다형성
* 하나의 메세지에 대해 고유한 방법으로 응답
* > 연관성
  * > is member of
    * 연관화 : 상호 연관되어있다
  * > is instance of
    * 분류화 : 동일한 형의 특성 객체
  * > is part of
    * 집단화 : 관련있는 객체를 묶어 상위객체
  * > is a
    * 일반화 : 공통적인 성질로 추상화한 상위객체 구성
    * 특수화 : 상위 객체를 구체화 하여 하위객체를 구성
> 럼바우 분석
* > 객체모델링
  * 연산과 속성등의 관계를 규정하여 객체다이어그램으로 표시
* > 동적모델링
  * 시간의 흐름에 따라 객체간 제어흐름, 상호작용등을 상태다이어그램으로 표시
* > 기능모델링
  * 자료흐름도를 이용하여 자료흐름을 중심으로 처리과정을 표시
> SOLID   
> S 
* Solo Responsibility
> O
* Open-close
* 확장에는 열려있어야 하고, 변경에는 닫혀 있어야 함
> L
* Liskov : super()
* 상위 타입 객체를 하위 타입 객체로 치환해도 정상적으로 동작해야 함
> I
* Interface Segregation
> D
* Dependency : child -> parent
* 구체화된 클래스에 의존하기 보다는 추상 클래스나 인터페이스에 의존해야 한다는 뜻
> 객체지향 설계분석론   
> Wrfs-Block
* 분석과 설계의 구분없이 고객명세서부터 설계작업까지 연속적 수행을 하는 설계론
> Rumhaugh
* 객체, 동적, 기능순으로 분석하는 분석론
> Booch
* Micro와 Macro로 나눠서 분석하는 방식
> Jacobson
* UseCase로 분석하는 방식
> Coad-Yorudon
* E-R 다이어그램을 사용하여 객체 행위 모델링을 통해 분석하는 방식
> 좋은소프트웨어
* 응집도는 높게(명령에 대한 구조) , 결합도는 낮게
> 응집도 순서 (아웃풋이 얼마나 스노우볼이 구르는지)
* > 기능적
  * 기능 요소들이 연관되어 수행될때의 응집도
* > 순차적 (순차가 끝나면 그다음은)
  * 모듈내의 활동으로 나온 [출력데이터를 그 다음 활동]으로 사용할 경우 응집도
* > 통신적 (통신한 모듈끼리 모이면)
  * 동일한 입력과 출력을 사용하여 서로다른 기능을 수행하는 구성요소들이 모였을 경우 응집도
* > 절차 (절차들이 모이면)
  * 모듈안의 구성요소들이 기능을 [순차적으로] 수행할 경우 응집도
* > 시간 (시간이 모여야)
  * 특성 시간에 처리되는 기능이 모여 응집
* > 논리 (논리가 된다)
* > 우연 : 어떤 의미도 없이 연관관계가 없는것
> 결합도(시스템 상호의존도, 모듈사이 연관관계) 순서 
* > 내용
  * 내부 자료를 직접참조
* > 공통
  * 공통 데이터 영역을 여러 모듈이 사용
* > 외부
  * 외부의 다른모듈에서 참조
* > 제어
  * 논리적인 흐름을 제어하기 위해 제어신호나 제어요소를 전달하는 결합도
* > 스탬프 (스탬프가 인터페이스를 의미)
  * 인터페이스로 배열이나 레코드 등의 자료구조가 전달되는 결합도
* > 자료
  * 인터페이스가 자료 요소로만 구성될때의 결합도
* FanIn/ FanOut -> 모듈의 수를 의미
> 단위모듈
* 독립적인 컴파일 가능, 다른모듈에 삽입되거나 호출될수도있음
* 한가지 동작을 수행하는 기능을 모듈로 구성
> 테스트 케이스
* 테스트 항목에 대한 명세서
> IPC
* 모듈간 통신방식을 구현하기위해 사용되는 대표적인 프로그래밍 인터페이스 집합
* > 대표메소드
  * > Shared Memory
    * 공유메모리를 구성
  * > Socket
    * 네트워크 소켓을 이용
  * > Semaphores
    * 공유자원 접근제어
  * > Pipes & named Pipes
    * Pipe라고 불리는 FIFO 메모리를 공유하여 통신
  * > Message Queueing
    * 메세지가 발생하면 이를 전달
> 공통모듈 명세기법
* 정확성
* 명확성
* 완전성
* > 일관성 
  * 공통 기능간 상호충돌이 발생하지 않아야함
* > 추적성 
  * 관련 시스템 관계 파악이 가능해야함
* 재사용
> 코드의 종류
* > 순차 코드 (일렬번호 코드)
  * 1,2,3,4
* > 블록 코드 (구분 코드)
  * 1001~1100 1101~1200
* > 10진 코드
  * 1000 : 공학, 1100 소프트웨어 공학 , 1110 소프트웨어 설계
* > 그룹 분류 코드
  * 1-01-001 : 본사
* > 연상 코드 (연상가능, 연상 < 표의)
  * TV-40 : 40인치 TV
* > 표의 코드 (깊이, 넓이, 부피를 그대로 적용 - 유효 숫자 코드)
  * 120-720-1500 : 120x720x1500 인 강판
* > 합성 코드
  * 연상 + 숫자 KE-711 : 대한항공 711기

GoF 디자인패턴의 종류
----
> 3가지 분류 기준
* 생성 / 구조 / 행위
  > 생성의 네가지 종류  
    * 팩토리 , 빌더 , 프로토 , 싱글톤
    * > 팩토리   
      * > 추상팩토리  
        * 인터페이스
      * > 팩토리 메소드 
        * 객체 생성을 서브클래스에서
    * > 빌더
      * 인스턴스의 조합
    * > 프로토
      * 원본객체를 복사
    * > 싱글톤   
  > 구조
    * > 구조값이라고 상상 가능한 패턴
      * > 어뎁터
        * 호환성 없는 클래스들을 이용할수 있도록 변환
      * > 브릿지
        * 구현부에서 추상층 분리, 독립적 확장
      * > 데코레이터
        * 객체간의 결합을 통해 능동적으로 기능확장
      * > 프록시
        * 접근하기 어려운 객체에 연결
    * > 구조값이라고 상상 불가능했던 패턴
      * > 컴포지트
        * 복합객체, 단일객체 구분없이 사용
      * > 퍼싸드
        * 복잡한 서프클래스를 피해 더 상위 인터페이스
      * > 플라이웨이트
        * 인스턴스를 가능한한 공유해서 씀
  > 행위
    * > 행위값이라고 상상 가능했던 패턴
      * > 책임연쇄
        * 객체가 둘 이상 존재하면, 한객체가 처리하지 못할시에 다음으로 넘어가는 패턴
      * > 옵저버
        * 변화하는 상태를 전달
    * > 행위값이라고 상상 불가능했던 패턴
      * > 상태
        * 객체의 상태값에 따라서 동일한 동작을 다르게 처리
      * > 방문자
        * 데이터 구조에서 처리기능을 분리, 별도의 클래스로 구성하는 패턴
      * > 커맨드
        * 요청을 객체의 형태로 캡슐화 하고, 로그에 남기는 패턴
      * > 인터프리터
        * 언어에 문법 표현을 정의
      * > 반복자
        * 동일한 인터페이스를 사용
      * > 중재자
        * 수많은 객체간의 복잡한 상호작용을 캡슐화
      * > 메멘토
        * 특정 시점의 객체 내부상태를 객체화
      * > 전략
        * 동일계열 알고리즘을 개별적으로 캡슐화
      * > 템플릿메소드
        * 상위 클래스에서 골격을 정의, 하위클래스에서 세부처리

> 디자인패턴에 대한 새로운 표현
* 자주 발생하는 문제에 대한 반복적인 해결방법
> 개발환경중 모르는용어
> IDEA
* JetBrains에서 만든 멀티 플랫폼 IDE
> 빌드도구
* Ant
  * 아파치 재단에서 개발한 자바의 공식빌드 도구
* > Maven
  * 아파치 재단에서 Ant 대안으로 개발
* Gradle
  * 한스 도커가 개발, 안드로이드 스튜디오의 공식 빌드 도구

> 배치프로그램 필수요소
* 대용량 데이터
* 자동화
* 견고성
* 안전성/신뢰성
* 성능

> 배치프로그램
* Spring Batch
* Quartz (오픈소스,작업과 시간관리 요소 분리)
* Cron

> Crontab
* 분 시 일 월 요일 명령어
* 미지정시 에스테리크 표시(*)

## Chapter 05 
> 인터페이스 검증
* 동료검토
* > 워크스루
  * 명세서를 미리 배포하여 사전검토후 검토회의
* > 인스펙션
  * 작성자를 제외한 다른 검토 전문가들이 명세서 확인
> 인터페이스 요구사항 검증항목
* 완전성
* 일관성
* 명확성
* 기능성
* 검증 가능성
* 추적 가능성
* 변경 용이성

> 송수신 데이터 식별
* 인터페이스 표준항목
* 송수신 데이터 항목
* 공통 코드

> 인터페이스 표준 항목
* > 시스템 공통부
  * 시스템 연동시 필요한 공통 정보
* > 거래 공통부
  * 연동된후 송수신데이터 처리시 필요한 정보

> 명세화 하기 필요한 정보
* 시스템 연계 기술
* 인터페이스 통신 유형
* 처리 유형
* 발생 주기

> 인터페이스 처리 유형
* 실시간
* 지연 처리
* 배치

> 시스템 연계 기술
* DB Link
* Api
* 연계 솔루션
* Socket

> 주요 미들웨어
* > RPC
  * Remote Procedure Call
* > MOM
  * 메세지 지향 미들웨어(비동기형 메세지를 전달하는 미들웨어)
* > TP-Monitor
  * 트랜잭션 처리 모니터
* > ORB
  * CORBA 표준 스펙을 구현한 객체 지향 
* > WAS
  * 동적인 콘텐츠를 처리하기 위한 미들웨어

> EAI
* > Point to Point
  * 1:1로 연결함, 변경및 재사용이 어려움
* > Hub & Spoke
  * 중앙 집중형 방식
* > Message Bus
  * 애플리케이션 사이에 미들웨어를 두어 처리하는 방식
* > Hybrid
  * Hub와 Message Bus의 혼합

> ESB
* EAI와 유사하지만 에플리케이션 보다는 서비스 중심의 통합

> 웹 서비스
* 서비스 지향 아키텍처(SOA) 개념 실현 대표적인 방법
* > SOAP
  * XML 기반의 프로토콜
* > UDDI
  * WSDL을 등록하여 서비스와 서비스 제공자를 검색하고 접근하는데 사용됨
* > WSDL
  * XML로 작성되며, UDDI의 기초가됨

> 인터페이스 데이터 표준
* 모듈간 인터페이스에 사용되는 데이터 형식을 표준화하는것

> 인터페이스 기능 구현 절차
* > 컴포넌트 명세서 확인
  * 컴포넌트의 개요및 내부클래스의 동작등, 인터페이스를 통해 외부와 통신하는 명세등을 정의
* > 인터페이스 명세서 확인
  * 컴포넌트 명세서의 항목중 인터페이스 클래스의 세부조건 및 기능 정의
* 인터페이스 기능 구현 정으
* 정의된 인터페이스 기능구현 정형화

> 인터페이스 엔티티를 이용한 인터페이스 구현
* 인터페이스 엔티티를 이용
* 일반적으로 인터페이스 테이블을 엔티티로 활용

> 데이터 무결성 검사도구
* Tripwire
* AIDE
* Samhain
* Claymore
* Slipwire
* Fcheck

> 인터페이스 구현 검증 도구   
* > xUnit
  * 단위테스트가 핵심   
* > TAF (* Automation *)  
  * > Test Automation Framwork
    * STAF, NTAF
    * 컴포넌트및 서비스 테스트 자동화가 핵심
* > FitNesse
  * Test Wiki
* > watir
  * Ruby Test

> 인터페이스 보안 기능
* > 네트워크 영역
  * IPSec, SSL, S-HTTP
* > 애플리케이션 영역   
  * 애플리케이션 코드상의 보안 취약점을 보완하는 방식
* > 데이터베이스 영역
  * 동작 객체의 보안취약점에 보안 기능을 적용

> APM
* 애플리케이션 성능관리 모니터링 도구
* 리소스방식
* > 앤드투엔드 방식
  * > 스카우터
    * OS 자원 모니터링
  * > 제니퍼
    * 테스트, 오픈, 운영 전단계 성능 모니터링

## Chapter 06 
> 사용자 인터페이스 구분
* CLI, GUI, NUI
> NUI
* > Pan   
  * Touch, Hold, Move
* > Flick   
  * Quickly Brush
* > Pinch   
  * Touch surface with Two Fingers and bring then closer or apart

> 기본원칙
* 직관성
* 유효성
* 학습성
* 유연성

> 와이어프레임 
* 레이아웃만
> 목업 
* 실제화면 정적형태
> 스토리보드 
* 와이어 프레임에 페이지간 이동흐름, 컨텐츠 설명 추가
> 프로토타입    
* 실제 구현도니것처럼 테스트 가능한 모형

> UI 설계 순서
* 요구사항 확인
* UI 구조 설계
* 메뉴 구조(사이트맵) 설계
* 화면 설계

> UX특징
* 주관성
* 정황성
* 총체성

## Chapter 07
> 애플리케이션 테스트 시각분류
* > 검증 테스트
  * 개발자 시각
* > 확인테스트
  * 사용자 시각

> 프로그램 실행 여부에 따른 분류
* 정적 테스트
* 동적 테스트

> 테스트 기반에 따른 테스트
* > 명세
  * 명세에 빠짐없이 테스트 케이스 작성
* > 구조
  * 논리 흐름에 따라 테스트 케이스 작성
* > 경험
  * 테스터 경험에 따라 테스트

> 화이트, 블랙박스 테스트 종류
* 동치분할검사
* 경계값 분석
* 원인-효과 그래프
* 오류 예측
* 비교

> 화이트박스 테스트의 검증 기준
* > 문장
  * 소스코드의 모든 구문이 한번 이상 수행
* > 분기
  * 모든 조건문에 대한 조건식 테스트 케이스 설계
* > 조건
  * 개별 조건문에 대한 조건식 테스트 케이스 설계 

> 테스트 분류
* > 회복
  * 올바르게 복구
* > 안전
  * 침입으로 부터 보호
* > 강도
  * 과부화
* > 성능
  * 실시간 성능, 효율성
* > 구조
  * 내부의 논리적인 경로, 소스코드의 복잡도
* > 회귀
  * 수정된 코드 결함없음
* > 병행
  * 동일한 데이터 입력, 결과비교

> 생명주기 V모델
* > 요구사항
  * 인수테스트
* > 분석
  * 시스템테스트
* > 설계
  * 통합테스트
* > 구현
  * 단위테스트

> 통합테스트
* > 점진적 통합테스트
  * > 상향식
    * 하위모듈을 클러스터로 결합
    * 드라이버 작성
    * 클러스터 검사
    * 드라이버를 제거하고 클러스터를 상위로 결합
  * > 하향식
    * 하위모듈 스텁으로 대체
    * 회귀 테스트 실시
  * 혼합식
* > 비점진적 통합테스트
  * 빅뱅 통합테스트

> 스텁이란?
* 서버가 구현, 하위모듈을 대체
* 하향식 통합테스트, 정해진 객체 결과값을 서버에 전달
> 태스트 드라이버란?
* 클라이언트가 후현, 상향모듈을 대체
* 인자값을 넘겨주는 상향식 통합테스트
> 테스트 오라클 
* 미리정의된 참을 대입하여 실제 결과와 비교
  * > 참 오라클
    * 모든 케이스에 대해서 전수테스트
  * > 샘플링 오라클
    * 특정 입력값들에 대해서만 원하는 결과제공
  * > 휴리스틱 오라클
    *  샘플링 오라클 개선, 참이 아닌 결과값은 휴리스틱(직관)처리
  * > 일관성 검사 오라클
    * 이전 수행결과와 현재 수행결과가 동일한지 검증

> 테스트 자동화 도구
* 정적 분석
* 테스트 실행
* 성능 테스트
* 테스트 통제 
* > 테스트 하네스
  * 테스트가 실행될 환경을 시뮬레이션 하여 컴포넌트와 모듈 테스트
  * 하네스의 구성요소로 드라이버와 스텁이 있음

> 결함 관리 측정 지표
* > 결함 분포
  * 결함수 측정
* > 결함 추세
  * 결함 추세
* > 결함 에이징
  * 결심상태 지속시간 측정

> 결함 분류
* 시스템
* 기능
* GUI
* 문서

> 애플리케이션 성능 측정 지표
* 처리량
* 응답시간
* 경과시간 (처리가 완료될때까지만 측정)
* 자원사용률

> 클린 코드 작성원칙
* 가독성
* 단순성
* 의존성 배제
* 중복성 최소화
* 추상화

## Chapter 08 
> DDL
* > CREATE
  * CREATE SCHEMA 이름 AUTHORIZATION ID
  * CREATE DOMAIN 이름 AS 데이터타입 DEFAULT CONSTRAINT
  * CREATE VEIW 뷰명 AS SELECT WITH CHECK OPTION
  * CREATE INDEX ON 테이블명  
  * CREATE TABLE 테이블명 ()
* > ALTER   
  * ALTER ADD
  * ALTER DROP COLUMN
* > DROP   

> DCL
* [DCL] [전치사]
* GRANT 사용자등급 to 사용자_ID_리스트;
* GRANT SELECT ON 고객 TO 홍길동;
* GRANT ALL ON 학생 TO 홍길동 WITH GRANT OPTION;
* REVOKE SELECT ON 교수 FROM 박문수 CASCADE; (연쇄삭제)
* ROLLBACK TO S2;

> DML
* > INSERT
  * INSET INTO 테이블 VALUES();
* > DELETE
* > UPDATE SET
* > SELECT
  * [SELECT] [PREDICATE] table [OPTIONS]
  * > LIKE PATTERN
    * _ , %
  * > GROUP Function
    * COUNT, SUM, AVG
  * > WINDOW Function 총정리
    * Group By 이용하지 않고 속성값 집계
    * COUNT, SUM, AVG, MAX, MIN, STDDEV, VARIANCE, ROLLUP, CUBE
  * > 집합연산자
    * UNION, UNIONALL, INTERSECT, EXCEPT
  * > JOIN
    * OUTER - 만족하지 않아도 출력
    * INNER - 만족해야 출력
> 트리거
  * DECLARE , EVENT, BEGIN , CONTROL , SQL , EXCEPTION , END
  * CREATE TRIGGER 학년정보_tri BEFORE INSTERT ON 학생 REFERENCING NEW AS new_table FOR EACH ROW WHEN (new_table.학년 IS NULL) BEGIN new_table 학년 := '신입생' END

## Chapter 09 
## Chapter 10
## Chapter 11
## Chapter 12



# 😃 설계와 테스트
</hr>

설계의 방향
-----  
> 상향식설계, 하향식설계 의 기준을 설명하시오 
* 설계의 세부사항, 인터페이스의 완성도가 아님  
* **결합의 여부**가 상향식이냐 하향식이냐

소스코드 품질분석 도구
----
> PMD (* mistacke *)
* PMD(Programming Mistake Detector)
* 응용 프로그램 코드에서 발견 된 문제를 보고 하는 오픈 소스 정적 Java 소스 코드 분석기
> cppcheck
*  Cppcheck는 크로스 플랫폼(윈도우, 데비안, 페도라, 맥 등)을 지원하며, 개발IDE에 플러그인으로 연동할 수 있습니다
> sonarQube
* 정적 코드 분석으로 코드 품질 검사용 오픈 소스 플랫폼
> ccm (* complicated *)
* 다양한 언어의 복잡도 분석
> cobertuna
* 자바 언어의 소스코드 복잡도 분석 및 테스트 커버리지 측정

테스트
----
> CASE(Computer Aided SoftWare Enginerring)
* 자동화 도구, 테스트 방법론
  > 상위 케이스
    * 문제를 기술, 설계 지원
  > 하위 케이스
    * 코드 작성테스트, 문서화 지원
  > 통합 케이스
    * 생명주기에 포함되어있는 전과정 지원


테스트 이론
----
> FTR (Formal Technical Review)
* 검토에만 집중하기 위해, 검토 이외의것을 모두 제한하는 방식(논쟁,인원 등등)
> Revese Engineering
* 일반적인 개발 단계와는 반대로 기존 코드를 복구하거나 소프트웨어 관계를 추출하는 방식
> Alien Code
* 참고문서와 관리하는 개발자가 없어 유지보수가 어려운 프로그램 코드
> 화이트박스 검사, 블랙박스 검사
* 실행 경로의 기초(내부적)를 정의하는 검사와, 내부를 보지않고 입력과 출력에 중점을 둔 검사의 차이
> 알파테스트 , 베타테스트
* 내부테스트(개발진, QA) , 상용테스트(일반인)   
<br/>

</br></br>


> CMM 모델 (조직의 성숙도)
* 초기 
* 관리 
* 정의 
* 정량 
* 최적화

</br></br>

# 😃 네트워크
</hr>

경로제어 routing 프로토콜
---
> IGP (Interior *)
  * > Interior Gateway Protocol (동일그룹)
  * > OSPF (* Shortest *)
    * Open Shortest Path First
  * > RIP (* imfomation *)
    * > Routing Infomation Protocol
      * Hop Counting
> EGP   
  * > Exterior Gateway Protocol (외부그룹)
> BGP   
  * > Boarder Gateway protocol (종속 게이트웨이)

> 임계 구역 접근 상호 배제
* Semaphore (신호깃발이라는 뜻)
> FAT -> NTFS
* 상대적 대용량, 대신 속도가 늘려짐 
> VLAN   
* 논리적으로 분할된 스위치 네트워크 : 동적인 조직에서 작업 그룹을 구성할 수 있음
> STP (* Tree *)
* Spannging Tree Protocol
* 2개 이상의 스위치가 여러 경로로 연결될때, 무한 루프 현상을 막기 위해 우선순위에 따라 1개로 통신하는 프로토콜
> L2AN
* OSI의 2계층에 속하는 장비
* MAC 주소를 기반으로 프레임을 전송하고 동일 네트워크 간의 연결만 가능
> SDS (Software *)
* Software Defined Storage 
* 스토리지를 가상화하여 여러 스토리지를 하나처럼 관리하거나, 여러 스토리지로 나눠 사용하는 소프트웨어
> SDDC (* data Center)
* Software-defined Data Center 
* 데이터센터의 모든 인프라인 네트워크, 스토리지, 컴퓨터, 보안 등이 가상화 되어 제공되는 데이터센터 솔루션
> MLFQ (Multi level *) 
* Multi-level Feedback Queue - MLFQ는 여러 개의 큐로 구성되며, 각각 다른 우선순위(Priority level)가 배정된다. 
* 실행 준비가 된 프로세스는 이 중 하나의 큐에 존재한다. MLFQ는 실행할 프로세스를 결정하기 위하여 우선순위를 사용한다. 
* 높은 우선순위를 가진 작업, 즉 높은 우선순위 큐에 존재하는 작업이 선택된다. 
> MQTT (Message * Transport)
* Message Queuing Telemetry Transport 
* 경량 머신 대 머신 통신에 사용되는 표준 기반 메시징 프로토콜
* 발행 - 구독 기반의 메세징 프로토콜
> Zingbee   
* 소형, 저전력 디지털 라디오를 이용해 개인 통신망을 구성하여 통신하기 위한 표준 기술
> MBR(master *)   
* master boot record - 파티션된 기억 장치(이를테면 하드 디스크)의 첫 섹터 (섹터 0)인 512 바이트 시동 섹터이다   
> NAC (* Access *)
* 네트워크 접근제어(Network Access Control)
* 인가된 장치만이 네트워크에 접속할 수 있도록 제한하는 것
> NIC(* interface *)
* 네트워크 인터페이스 컨트롤러(network interface controller, NIC)
* 네트워크에 연결하여 통신하기 위해 사용하는 하드웨어 장치
> Topology   
* 단어 그 자체로 망 구성방식
* 컴퓨터 네트워크의 요소들(링크, 노드 등)을 물리적으로 연결해 놓은 것, 또는 그 연결 방식
> SNMP (Simple Network *)
*  UDP/IP(사용자 데이터그램 프로토콜/인터넷 프로토콜)를 사용하여 이더넷 연결을 통해 네트워크 관리 작업을 수행하는 응용 계층 프로토콜 
> FLSM (Fixed Length *)
* Fixed Length Subnet Mask  <-> VariableLength Subnet Mask
> ARQ (* Request)
* ARQ는 Automatic Repeat Request
* 에러가 발생할 경우 재전송을 요구하는 방식이다. 
> 유니캐스트 , 브로드캐스트 , 멀티캐스트, 애니캐스트
* 유니캐스트는 한 PC에게만 보내는 1:1
* 브로드 케스트는, 도메인 안에있는 모든 PC들에게 보내는 형태
* 멀티캐스트는, 원하는 그룹에게만 보내는방식
* 애니캐스트는 가장가까운 Node에게 보내는 방식
> Wi-Sun
* Wireless Smart Utility Network
* 일본에서는 특정 소전력 무선으로 일컬어지는 920MHz 대에서 사용
> Sliding Window
* 일단 '윈도(메모리 버퍼의 일정 영역)'에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인되는대로 이 윈도를 옆으로 옮김(slide)으로서 그 다음 패킷들을 전송하는 방식
> GPIB(* Purpose Interface *)
* General Purpose Interface Bus
* PC를 통하여 계측기나 기타 장비 등 표준 프로토콜로 병렬 및 고속 제어하기 위하여 사용

IPv4와 IPv6정리
----
> 유니캐스트(1:1 통신 주소 자동설정)
* IPv4 
> 클래스별로 4개
* IPv4 
> 16비트 8개 -> 128비트
* IPv6
> 40옥텟 해더
* IPv6
> 속도가 비교적 빠르고 v4와 호완
* IPv6
> 패킷 크기가 고정 / 비고정
* IPv4 / IPv6

TCP/IP + UDP
----
> ARP(Address * *)
* IP to MAC Address (Address Resolution Protocol) 프로토콜
> ICMP (* Message Protocol)
* Error Message - Internet Control Message Protocol
> Point to Point
* 각각 서버와 클라이언트가 둘다 될수있는 방식(Point to Point)의 프로토콜
> TCP/UDP
* 차이는 연결형 / 비연결형 으로 속도와 신뢰성의 문제
> OSI 2계층은 인접하는 신뢰, 종단간은 신뢰는
* 4계층

IPv4 Class 정리
----
> A (0)   
* 0.0.0.0 ~ 127.255.255.255
> B (10)   
* 128.0.0.0 ~ 191.255.255.255
> C (110)
* 192.0.0.0 ~ 223.255.255.255
> D    
* 224.0.0.0 ~ 239.255.255.255
> E    
* 240.0.0.0 ~ 247.255.255.255
> 기준값
* 127부터 64 / 32 / 16 / 8을 더함

DRM
---
> Clearing House    

> Contents Provider   

> Packager   

> Contents Distributor   

> DRM Controller   

> Security Container   

DFS
----
> 순회 기준 우선순위
* 자식, 형제, 상위

</br></br>

병렬 데이터베이스 수평분할
---
> 데이터 튜닝기법
  * > 목록분할
    * 특정 칼럼을 기준으로 파티셔닝
  * > 조합분할
    * 여러가지를 조합하여(합성) 파티셔닝
  * > 해시분할
    * 해시 함수를 적용하여 파티셔닝
  * > 범위분할
    * 범위에 있는지 여부로 파티셔닝
  * > 라운드 로빈
    * 행의 고른 분포로 파티셔닝

추가개념
----
> OLAP 
* 중앙화된 통합 데이터 저장소의 대용량 데이터를 분석하는 소프트웨어
* > 롤업(roll-up)
  * 작은 단위에서 큰 단위로 이동하는 연산(차원 낮추기)
* > 드릴다운(drill-down)
  * 큰 단위에서 작은 단위로 세분화, 롤업 프로세스의 반대(차원 높이기)
* > 슬라이스(slice, slicing)
  * 큐브의 한 조각을 연산, 큐브의 한 단면 보기(1개 차원 선택)
* > 다이스(dice, dicing)
  * 슬라이스와 비슷, 하위 큐브 만들기 위해 2개 이상 차원 선택
* > 피벗(pivot)
  * 데이터 축을 회전하여 제공
> STDDEV
* 표준편차
> VARIANCE
* 분산
> 분산데이터 특성
* Location / Replication / Failure / Concure

</br></br>

# 😃 운영체재
</hr>

가상기억장치 구현
---
> 보조기억장치(하드디스크)를 주기억장치처럼 사용(RAM)
  * > 페이징
    * 내부단편화
    * 가상과 주기억을 동일하게 나눈뒤 적재
    * > 페이징맵 테이블 
      * 비용증가, 처리속도 느려짐
  * > 세그멘터이션
    * 외부단편화
    * 가상과 주기억을 논리적으로 나눈뒤 적재
    * 세그멘테이션 테이블

교착상태 조건
----
* 상호배제
* 점유와 대기
* 환형대기
* 비선점

프로세스 상태 순서
----
* Submit
* Hold
* Ready
* Run
* Wait
* Block
* Terminated

운영체재 자원 배분
---
> Best , Worst, First Fit의 정의   
* 어떻게 배치할 것인가
> 스레싱
* 프로레싱 처리기간보다, 쓰레드 배치 시간이 길어지면 나타나는 현상
* 페이지 부재가 많아짐
> 교착상태 해결법 
* > 예방
  * 교착상태 발생조건 제거(부정)
* > 회피
  * 은행원 알고리즘
* > 발견
  * 자원할당 그래프
* > 회복
  * 프로세스 자원 회복

> SecureOS
* 컴퓨터 사용자에 대한 식별 및 인증, 강제적 접근 통제, 임의적 접근 통제, 재사용 방지, 침입 탐지 등의 보안 기능 요소를 갖추어진 운영체제

> SSTF Scheduling   
* (Shortest Seek Time First) : 현재 디스크의 헤드 위치에서 가장 가까운 실린더에 대한 요청을 우선적으로 처리한다.
> HRN ( * Ratio * )
* Hightest Response-ratio Next (대기시간 + 서비스시간) / 서비스시간

페이지 교체 알고리즘
----
> FIFO
> OPT
* 가장 오래 사용하지 않은것 교체
> LRU
* Least Recently Used <> OPT
> LFU
* Least Frequenly Used
> MFU
* Most Frequenly Used

리눅스
----
> umask
* 초기 권한 설정값으로 파일은 666, 폴더는 777 에서 뺴는값
> 쉘스크립트 Export
* 환경변수를 설정
> fork
* 새로운 프로세스 생성
> fsck
* 파일시스템을 검사 / 보수
> netcat
* TCP 또는 UDP를 사용하여 네트워크 연결을 읽거나 기록하는 컴퓨터 네트워킹 유틸리티
> cron
* job scheduler
> SetUID
* 실 사용자에서 프로그램 소유자ID로 유효사용자가 변경됨 (권한 상승 우려 때문에 반드시 최소화해야함)

ISO 용어 정리
----
> ISO/IEC 25000
* 소프트웨어 품질 관련 국제 표준, 2501n은 외부 품질, 2502n은 내부 품질 기준
> ISO 12207와 SPICE 비교   
* https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=azurecourse&logNo=220041626265
* 소프트웨어 프로세스 능력 측정 국제표준

잊기 쉬운 짧은 개념들
----
> Hash함수
* 일방향 함수다.
* HAVAL , SHA-1
> 기수변환
* 다른 진법으로 간주하고 키를 변환하여 홈 주소를 얻는 방법
> 폴딩
* 키값을 여러부분으로 나눈후 각부분의 값을 더하거나 XOR연산후 주소
> CIDR 서브넷마스크 계산법
* /(1의 갯수) 와 옥텟을 기억
> 방식
* > 선형 탐사
  * 선형적으로 옮겨 액세스
* > 제곱 탐사
  * 제곱으로 이동해서 엑세스
* > 이중해싱
  * 규칙성을 없애버려서 클러스터링 방지
* > 전위식, 후위식
  * 연산가능한것을 해당방향으로 묶는것
* > 스키마 종류 (관점)
  * > 개념 스키마
    * 데이터 베이스의 전체적인 논리구조
  * > 내부 스키마
    * 데이터베이스의 물리적 저장구조를 정의
  * > 외부 스키마
    * 사용자나 응용프래그래머가 개인의 입장에서 필요한 데이터 베이스의 구조를 정의
> BaaS
* 서비스형 블록체인 (Blockchain as a Service)
> 스마트 그리드
* 전기 및 정보통신 기술을 활용하여 전력망을 지능화·고도화함으로써 고품질의 전력서비스를 제공하고 에너지 이용효율을 극대화하는 전력망
> 디지털 아카이빙
* 지속적으로 보존할 가치를 가진 디지털 객체를 장기간 관리하여 이후의 이용을 보장하는 활동
> Fcheck 
* 파일 시스템의 상태를 체크함으로써 간단히 파일 시스템의 무결성을 감시 한다
> 운행순서 (Root - order)
* preorder
* inorder
* postorder
> 디지털트윈
* 라이프사이클 전반에 걸쳐 실시간 데이터를 사용
* 시뮬레이션, 머신 러닝, 추론을 통해 의사 결정을 돕는 객체 또는 가상 모델
> Zing
* NFC에 사용되는 근거리 기술
> WPA
* Wi-Fi Protected Access
> 링크드 리스트
* 삽입, 삭제가 쉬운대신 검색속도가 오래걸림
> RDB
* 속석의 이름 / 속성의 값으로 튜플을 표현
* 튜플은 상이한것으로 정의내림
> cmp in C
* 비교하는 함수
> & in C
* 메모리의 주소를 의미
> ER Diagram의 이중속성과 기본키속성 표현방법   
> 리눅스 로그파일
* xferLog
* > wtmp
  * 성공한 로그인에 대한 로그
* > utmp
  * 현재 로그인 한 사람의 정보 로그
> 데이터 베이스의 투명성 목표
* A에 대하여 관계없이~~ -> A의 투명성
* 무엇에 대하여 관계없는지를 파악하는것이 중요
> 비트연산 기호
* ^ - XOR - 배타적 논리합(둘이 다르면 참) 
* ~ - NOR - Not OR   
> 암호화 방식 정리
* > 대칭키
  * 송수신자가 같은키를 가지고있어서 키교환이 가장 중요한부분
  * DES/ AES / SEED
* > 공개키
  * 대칭키 키교환문제 해결
  * 수신자의 공개키로 암호화
  * 당연히 수신자는 개인키로 복호화 가능
  * RSA
* > 개인키
  * 개인키로 암호화해도 누구나 공개키로 열수있다.
  * 보안이 중요한게 아니라 누가 암호화했는지를 정확히 알수있어서 인증에 사용된다.
  * 전자서명, 공인인증체계의 기초

</br></br>

# 😃 언어 개념 
</hr>

C언어 포인터 정리
----
> 연산자 우선순위 총정리
* 일단산비관트논조대콤
* 일차식, 단항, 산술, 비교, 관계, 비트, 논리, 조건, 대입, 콤마
* [](일차) , *(단항)
* 나머지는 넘기기
> 참조와 역참조
* *p *(*p)
* 역참조 할때마다 한단계 위로 올라간다고 생각하면 편함(다차원배열에서)
> 포인터 배열과 배열의 포인터
* int *p[3]
* int (*p)[3]
> 비트연산기호   
> 라이브러리   
> 함수정리
* > atoi
  * alphabet to integer
  * a (to) i 로 인지
* > atof , itoa, ceil... etc)
> sanf
* C언어의 표준 입력 함수
기타언어
----
> << 시프트 기호의 의미   
* 2진수를 하나밈 
> Scrapy
* 파이썬 기발 크롤링 프레임 워크
> 파이썬 슬라이스
* [초기:최종:증가값]
> @
* 오류제어 연산자

</br></br>

# 😃 보안과 오류 
</hr>

* 디버깅은 오류의 수정을 이야기함
> postfix
  * >  연산자가 피연산자 두개뒤에 놓이는 방식
      * Stack으로 연산

Buletooth Attack
----
> Bug 
* 원격조정, 전화, 감청
> narf (허겁지겁먹다)
* 파일에 접근
> Printing 
* 검색을 하는 활동
> Jacking 
* 명함을 익명으로 퍼뜨림

DOS
----
> smurfing (스머프??) 
* ICMP(error)를 활용하여 집중적으로 대용량 데이터 공격
> Ping of Death 
* 정상크기보다 큰 ICMP를 쪼개서 보내어 패킷을 처리하게 만듬
> SYN Flooding (Sync)
* 존재하지 않는 클라이언트가 접속하여 다른 사용자 사용불가능하게 만듬
> Land 
* 출발지와 목적지 IP를 동일하게 만듬
> Honeypot
* 비정상적인 접근 탐지
* 침입자를 속여 쉽게 공격이 가능한것처럼 보임
> DPI (Depp *)
* (Deep Packet Inspection) - 해킹 탐지, 트래픽 조정, OSI 전 레이어 탐지
> PLCP (Packet *)
* Packet Level Control Processor - 패킷 교환 시스템에서 정보 처리와 통계 등을 담당
> 암호화 알고리즘
* MD4, 5 (해시)
* SHA-1
* AES
* RSA


코드기입오류 정리
----
* Transcription
* Transposition
* Double Transposition
* Omission
* Addtion
* Random

SSH
----
  * > 기능   
  * > Default Port
    * 22
  * > 공개키 위치
    * SERVER
  * 원격명령, 쉘 서비스

암호화
----
> DES
* 64비트 알고리즘
> AES
* DES를 발전, 128비트 알고리즘
> RSA
* 소수로 암호화 비대칭 암호화
> 비대칭 알고리즘 공개키 / 비밀키 암호화 차이
* 공개키 - 신뢰단체라는것을 인증하는 관점
* 개인키 - 데이터를 안전하게 전송한다는 관점
> Authorization / Authentication
* 인가 / 인증

보안및 공격방식
----
> Secure 코딩
* 공격자가 프로그램 코드를 실행시키게 만드는 방식 - 작동이 목적임
> C&C Server   
* Command & Control 서버 
* 사이버 공격에서 두뇌 역할
> Botnet   
* 좀비 PC
> Zero Day Attack  
* 패치가 나오지 않은 시점에서 이루어지는 공격 
> Key Logger Attack   
* 컴퓨터 사용자의 키보드 움직임을 탐지해서 저장하고, ID나 패스워드, 계좌 번호, 카드 번호 등과 같은 개인 중요 정보를 몰래 빼가는 해킹
> Back Door
* 어떤 제품이나 컴퓨터 시스템, 암호시스템 혹은 알고리즘에서 정상적인 인증 절차를 우회하는 기법
> Brute-Force Attack   
* 암호학 무차별 대입공격
> Ping Flood   
* system에 ICMP packet을 계속해서 보내서, 대상 system이 Request 에 응답하느라 다른 일을 하지 못하도록 하는 공격
> Opcode   
* 기계어에서 명령코드를 나타내는 부호
> Salt  
* 데이터, 비밀번호, 통과암호를 해시 처리하는 단방향 함수의 추가 입력으로 사용되는 랜덤 데이터이다
> OWASP(Open *)   
* 오픈 소스 웹 어플리케이션 보안 프로젝트
* 가장 큰 오픈소스 웹 애플리케이션 보안 프로젝트
* 웹에 관한 정보노출, 악성 파일 및 스크립트, 보안 취약점 등을 연구
> Collision Domain   
* 동일한 collision domain에서 하나의 PC가 통신할 경우, 다른 모든 PC는 통신이 불가
> CSMA/CA  (A) 
* Carrier Sense Multiple Access / Collision Avoidance
* 반송파 감지 다중 엑세스 충돌 회피
> CSMA/CD  (D)
* Carrier Sense Multiple Access / Collision Detect
* 반송파 감지 다중 엑세스 충돌 감지
> DSA   
* DSA는 미국의 전자서명 표준이다.
> IPSec  
* 네트워크에서의 안전한 연결을 설정하기 위한 통신 규칙 또는 프로토콜 세트 
* 터널모드와 전송모드
* 전송모드는 헤더로르 제외한 페이로드만 보호
* 터널모드는 전체 패킷을 보호
> nmap  
* NMAP은 port Scanning 툴(해킹방어)
> 세션하이재킹
* 세션이 활성화된상태(로그인)을 가로채는것
* ACK Storm 탐지 , 비동기화상태 탐지, 패킷의 유실과 재전송증가탐지, 기대하지 않는 접속의 리셋 확인
> ACK Storm
* 세션하이재킹시에 패킷의 유실이 많이 일어나는데, 이때 패킷량이 비정상적으로 재전송이 일어나면서 증가하는 현상
> SMTP (Simple Mail)
* 간이 우편 전송 프로토콜(Simple Mail Transfer Protocol)의 약자로, 이메일 전송에 사용되는 네트워크 프로토콜이다.
> S-HTTP
* S-HTTP는 웹상에서 네트워크 트래픽을 암호화하는 주요 방법 중 하나이다. 
* 웹상에서 네트워크 트래픽을 암호화하는 것에는 주로 2가지 방법을 사용하는데 한 가지는 S-HTTP 이고 다른 하나는 SSL이다.
> ESB (Enterprise * Bus)
* 표준화된 메시지 버스와 프로토콜을 이용해서 서로 연동할 수 있는 시스템
> Pharming
* 피싱(가짜)사이트로 유도, 금융정보를 탈취하여 유출된 정보로 예금인출하는 방식
> Trin00
* trinoo 또는 trin00은 DDoS 공격을 수행하기 위한 일련의 컴퓨터 프로그램

<br/>   

기타 외워야하는 Service및 기술들
----
> Stacheldraht
* 분산서비스 거부공격을 하는 멜웨어
> TFN(* Network)
* Tribe Flood Network
* 다양한 DDoS 공격을 수행하는 컴퓨터 프로그램 집합
> Nimda
* 님다는 2001년 9월에 발생한 컴퓨터 바이러스이다
> PIMS(Personal Information *)
* Personal Information Management System
* 기업이 개인정보 보호 활동을 체계적, 지속적으로 수행하기 위해 점검하여 일정 수준 이상의 기업에 인증을 부여하는 제도
> QKD(Quantum *)
* Quantum Key Distribution 
* 양자 물리학의 기본 원리를 활용하여 검증 가능한 보안으로 광섬유 네트워크를 통해 암호화 키를 교환하는 기술
> Grayware
* 사용자의 동의를 받아 다운받는 (불편함을 유발) 프로그램 - adware가 속함
> Mashup
* Web info -> new System
> 타조   
* 하둡(Hadoop) 기반의 분산 데이터 웨어하우스 프로젝트
> 원세그
* 일본의 이동방송 기술   
> 포스퀘어   
* 위치 기반 소셜 네트워크 서비스이자 이를 개발한 회사의 명칭
> ASLR  
* Address Space Layout Randomization
* 주소 공간 배열 무작위화. 말 그대로 주소를 매번 실행할 때마다 무작위화시켜 공격을 방해 
> Sqoop 
* Hadoop과 관계형 데이터베이스 간에 데이터를 전송할 수 있도록 설계된 오픈소스 소프트웨어  
> N-Screen   
* 특정한 주제의 콘텐츠들을 여러 개의 스크린에서 동시에 볼 수 있다는 개념
> Memristor   
* Memory registor (이전의 상테를 기억하는 메모리)
> MEMS   
* Micro Electro Mechanical Systems (미세 전기 기계 시스템)의 약자
* 미세한 입체 구조 (3차원 구조)를 지니며, 다양한 입력 · 출력 신호를 취급하는 시스템의 총칭
> evil twin attack
* 로그온한 사람들을 속이고 비밀번호나 신용카드 번호를 훔치기 위해 합법적인 네트워크인 것처럼 가장한 무선 네트워크
> phisihing
* 컴퓨팅에서 피싱(phishing)은 전자우편 또는 메신저를 사용해서 신뢰할 수 있는 사람 또는 기업이 보낸 메시지인 것처럼 가장
* 비밀번호 및 신용카드 정보와 같이 기밀을 요하는 정보를 부정하게 얻으려는 소셜 엔지니어링
> cyberbulling
* 특정 메신저에 특정 학생을 초대해서 단체로 괴롭히는 행동
> tripwire
* 먼저 시스템에 존재하는 파일에 대해 데이터 베이스를 만들어 저장한 후 생성된 데이터베이스와 비교
* 추가·삭제되거나 변조된 파일이 있는지 점검하고 관리자에게 레포팅해주는 무결성 검사도구
> MapReduce
* 필터링과 정렬을 거쳐 데이터를 추출(Reduce)하는 분산처리 기술과 관련된 Framework를 의미
>  NS Chart
* http://itnovice1.blogspot.com/2019/08/nsnassi-schneiderman.html
